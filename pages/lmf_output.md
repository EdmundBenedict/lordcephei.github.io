---
layout: page-fullwidth
title: "Annotation of standard output, program lmf"
subheadline: ""
show_meta: false
teaser: ""
permalink: "/docs/outputs/lmf_output/"
header: no
---

_____________________________________________________________

### _Purpose_
{:.no_toc}

This page details the output generated by the band program **lmf**{: style="color: blue"}.

_____________________________________________________________

### _Table of Contents_
{:.no_toc}
*  Auto generated table of contents
{:toc}  

The output documented here is mostly taken from the **lmf**{: style="color: blue"} 
[tutorial for PbTe](/tutorial/lmf/lmf_pbte_tutorial/).
Some portions are adapted from other calculations, as will be indicated.

The standard output is organised by blocks.  Each section below
explains a block approximately in the order they are made.

#### Preprocessor's transformation of the input file
{::comment}
/docs/outputs/lmf_output/#preprocessor's-transformation-of-the-input-file
{:/comment}

<div onclick="elm = document.getElementById('preprocessor'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
Click here for a description.</div>
{::nomarkdown}<div style="display:none;padding:0px;" id="preprocessor">{:/} 

**lmf**{: style="color: blue"} begins by running the ctrl file through
the preprocessor.  Normally it does this silently.  If you want to see the effects of the preprocessor use `lmf --showp ...`
Adapting the **lmf**{: style="color: blue"} command in the [PbTe tutorial](/tutorial/lmf/lmf_pbte_tutorial/#/tutorial/lmf/lmf_pbte_tutorial/#self-consistency)

~~~
$ lmf ctrl.pbte -vnkabc=6 -vgmax=7.8 --showp
~~~

the result is

~~~
VERS  LM:7 FP:7
IO    SHOW=f HELP=f IACTIV=f VERBOS=35,35  OUTPUT=*
EXPRESS
  file=   site

  gmax=   7.8
  autobas[pnu=1 loc=1 lmto=5 mto=4 gw=0]

  nit=    10
  mix=    B2,b=.3,k=7
  conv=   1e-5
  convc=  3e-5

  nkabc=  6
  metal=  5

  nspin=  1
  so=     0
  xcfun=  2,0,0

HAM
      PWMODE=0 PWEMIN=0 PWEMAX=3
      FORCES=1 ELIND=-0.7
SPEC
  ATOM=Pb         Z= 82  R= 3.044814  LMX=3  LMXA=4
  ATOM=Te         Z= 52  R= 3.028689  LMX=3  LMXA=3
~~~

Compare to the original _ctrl.pbte_{: style="color: green"}.

{::nomarkdown}</div>{:/}

#### Display of tags parsed in the input file
{::comment}
/docs/outputs/lmf_output/#display-of-tags-parsed-in-the-input-file
{:/comment}

<div onclick="elm = document.getElementById('tags'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
Click here to see how to determine what input lmf reads.</div>
{::nomarkdown}<div style="display:none;padding:0px;" id="tags">{:/} 

After transformation by the preprocessor, lmf parses for tags and substitutes default values for tags it does not find.  By default this
reading is silent.  You can see what **lmf**{: style="color: blue"} reads (or assigns as defaults) by in inserting a command-line argument
`lmf --show=2 ...` or `lmf --show ...` . In the former case **lmf**{: style="color: blue"} prints values for all the tags it parses or
substitutes and stops.  In the latter **lmf**{: style="color: blue"} proceeds with the calculation as normal
and is useful if you want to save detailed documentation of the input conditions.

Example:

~~~
$ lmf ctrl.pbte -vnkabc=6 -vgmax=7.8 --show=2
~~~

The output is quite verbose and is not shown here. [This page](XXX) explains how to interpret the output generated by `--show`.

{::nomarkdown}</div>{:/}

####  Reading basis information from the basp file
{::comment}
/docs/outputs/lmf_output/#reading-basis-information-from-the-basp-file
{:/comment}

After parsing the ctrl file, **lmf**{: style="color: blue"} may attempt to read
basis set information from the basp file.  Tokens in
**EXPRESS_autobas** or **HAM_AUTOBAS**  control what is read from the basp file.

<div onclick="elm = document.getElementById('basp'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
Click here for a description.</div>
{::nomarkdown}<div style="display:none;padding:0px;" id="basp">{:/} 

basis information (envelope function parmeters, _P_ parameters and information
about local orbitals) from _basp.pbte_{: style="color: green"}.

~~~
 rdctrl: reading basis parameters from file basp
 ioorbp: read species Pb        RSMH,EH RSMH2,EH2 P PZ
 ioorbp: read species Te        RSMH,EH RSMH2,EH2 P
         reset nkaph from 1 to 3
~~~

You can also supply this information in the ctrl file.
If both are present **lmf**{: style="color: blue"} decides on which to
use depending on settings in **EXPRESS_autobas**.

To see what the tokens in **autobas** do, invoke `lmf --input`
and search for autobas in the output.

Look [here](/docs/input/inputfile/#help-with-finding-tokens:-the---input-switch)

{::nomarkdown}</div>{:/}

#### Header information
{::comment}
/docs/outputs/lmf_output/#header-information
{:/comment}

The header information presents a condensed synopsis of some key
settings that are used in the the calculation.

~~~
 LMF:      nbas = 2  nspec = 2  vn 7.11.i  verb 35
 special:  forces
 pot:      XC:BH
 float:    float P LDA-style
 autoread: mto basis(4), pz(1), pnu(1)
 bz:       metal(5), tetra, invit 
~~~

#### Lattice information
{::comment}
/docs/outputs/lmf_output/#lattice-information
{:/comment}

This block prints informations about the lattice vectors and settings used in Ewald summations:

~~~
                Plat                                  Qlat
   0.000000   0.500000   0.500000       -1.000000   1.000000   1.000000
   0.500000   0.000000   0.500000        1.000000  -1.000000   1.000000
   0.500000   0.500000   0.000000        1.000000   1.000000  -1.000000
   alat = 12.147006  Cell vol = 448.071898

 LATTC:  as= 2.000   tol=1.00E-08   alat=12.14701   awald= 0.261
         r1=  1.807   nkd= 87       q1=  5.403   nkg= 169
~~~

_Note:_{: style="color: red"} When long, thin cells are used, or when APW's are added to the basis set, some attention needs to be paid to the Ewald tolerance.

#### Symmetry information
{::comment}
/docs/outputs/lmf_output/#symmetry-information
{:/comment}

The block below shows symmetry operations it finds in the 
crystal, and the irreducible k mesh it obtains from the point group it is given:

~~~
 SGROUP: 1 symmetry operations from 0 generators
 SYMLAT: Bravais system is cubic with 48 symmetry operations.
 SYMCRY: crystal invariant under 48 symmetry operations for tol=1e-5
 GROUPG: the following are sufficient to generate the space group:
         i*r3(1,1,-1) r4x
         i*r3(1,1,-1) r4x
 MKSYM:  found 48 space group operations ... includes inversion
 BZMESH:  16 irreducible QP from 216 ( 6 6 6 )  shift= F F F
 TETIRR: sorting 1296 tetrahedra ... 35 inequivalent ones found
~~~

Notes: (see also "Additional Exercises" below)

+ You can specify symmetry operations manually.  This is particularly useful
  when magnetic symmetry must be considered.  
+ The k mesh is specifed through the number of k divisions along each of the three reciprocal lattice vectors, tag **EXPRESS_nabc**.  
  You can also specify whether the k-mesh should pass through the origin or straddle it
  through tag **BZ_BZJOB**.
+ The Brillouin zone integration is using Bloechl's generalized tetrahedron method.
  You can also use the Methfessel-Paxton integration scheme or a Fermi function.

#### Augmentation parameters
{::comment}
/docs/outputs/lmf_output/#augmentation-parameters
{:/comment}

The table below contains a synopsis of key parameters associated with augmentation spheres.

~~~
 species data:  augmentation                           density
 spec       rmt   rsma lmxa kmxa      lmxl     rg   rsmv  kmxv foca   rfoca
 Pb       3.045  1.218    4    3         4  0.761  1.522    15    1   1.218
 Te       3.029  1.211    3    3         3  0.757  1.514    15    1   1.211
~~~

+ **rmt** is the augmentation radius
+ **rsma** and **kmxa** are the smoothing radius and polynomial order used to expand envelope function around other sites.
+ **lmxa** is the _l_-cutoff of the augmentation.  Because of the unique way augmentation is done in this method, **lmxa** can be much lower standard augmented wave methods require
+ **lmxl** is analogous to **lmxa**, but it controls the _l_-cutoff of the charge density.  **lmxl** defaults to **lmxa**; you can often make it smaller with minimal loss of accuracy.
+ **rg**, **rsmv**, **kmxv** are concerned with adding local gaussian pseudocharges to manage the Hartree potential.
+ **foca**, **rfoca** allow for differing treatments of the core.

#### Interstitial mesh
{::comment}
/docs/outputs/lmf_output/#interstitial-mesh
{:/comment}

The following block is concerned with the mesh used to represent the charge density,
and to evaluate matrix elements of the (unaugmented) envelope functions
The spacing of the mesh is controlled by the _G_ cutoff (**7.8** for PbTe).

~~~
 MSHSIZ: mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
         generated from gmax = 7.8 a.u. : 3647 vectors of 5832 (62%)

 GVLIST: gmax = 7.8 a.u. created 3647 vectors of 5832 (62%)
         mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
 SGVSYM: 126 symmetry stars found for 3647 reciprocal lattice vectors
~~~ 

Information about whether this mesh is sufficiently accurate is given
in the table beginning with _sugcut_{: style="color: green"} below.

#### Counting the size of the basis
{::comment}
/docs/outputs/lmf_output/#counting-the-size-of-the-basis
{:/comment}

In the table below, the size of the basis is presented.
**lmf**{: style="color: blue"} doesn't have downfolding capability, so the
important numbers are those in the "low" column.  Rows 1,2,3 indicate how
many orbitals are connected respectively with the first Hankel envelope (**EH**),
the second envelope (**EH2**), and local orbitals.
The total basis (and hamiltonian rank) consists of 55 orbitals.

~~~
 Makidx:  hamiltonian dimensions Low, Int, High, Negl: 55 0 32 63
 kappa   Low   Int   High  L+I  L+I+H  Neglected
   1      32     0     9    32    41       9
   2      18     0    23    18    41       9
   3       5     0     0     5     5      45
  all     55     0    32    55    87      63
 suham :  41 augmentation channels, 41 local potential channels  Maximum lmxa=4
~~~

#### Envelope function parameters and their G cutoffs
{::comment}
/docs/outputs/lmf_output/#envelope-function-parameters-and-their-g-cutoffs
{:/comment}

In the table envelope function parameters for each species is given,
which defines their shape.   Also shown is an orbital-dependent **gmax**.

~~~
 sugcut:  make orbital-dependent reciprocal vector cutoffs for tol=1.0e-6
 spec      l    rsm    eh     gmax    last term   cutoff
  Pb       0    1.80  -0.10   4.123    2.68E-06     531 
  Pb       1    2.02  -0.10   3.848    2.42E-06     411 
  Pb       2*   2.03  -0.10   4.013    1.37E-06     531 
  Pb       3    2.03  -0.10   4.193    1.54E-06     537 
  Pb       0    1.80  -0.90   4.123    2.68E-06     531 
  Pb       1    2.02  -0.90   3.848    2.42E-06     411 
  Pb       2    2.03  -0.90   4.013    1.37E-06     531 
  Te       0    1.63  -0.10   4.572    1.45E-06     725 
  Te       1    1.71  -0.10   4.575    1.52E-06     725 
  Te       2*   2.02  -0.10   4.037    1.63E-06     531 
  Te       3    2.02  -0.10   4.218    1.87E-06     537 
  Te       0    1.63  -0.90   4.572    1.45E-06     725 
  Te       1    1.71  -0.90   4.575    1.52E-06     725 
  Te       2    2.02  -0.90   4.037    1.63E-06     531 
~~~ 

Each envelope function must be expanded in plane waves in order to assemble matrix elements of the interstitial potential
the output charge density.  
Both are assembled in reciprocal space.
The number of plane waves needed for a particular orbital depends on how sharply peaked the function is,
so the cutoff is orbital-dependent to allow for faster execution.
**gmax** of any one orbital may safely be less than the global _G_ cutoff (**7.8** for PbTe);
if it can, _lmf_{: style="color: blue"} will find a **gmax** for each orbital
that meets a preset tolerance.  Otherwise it uses all the _G_ vectors available to it, and appends a '\*' to the number indicating 
not enough orbitals are available to meet the specified tolerance (10<sup>&minus;6</sup> in this case).

If any of the orbitals bump up against the maximum, check the error estimate ("last term") in the Table.
If it is too high you can expect errors in the hamiltonian and you should increase **gmax**.

The tolerance defaults to 10<sup>&minus;6</sup>, but you can control it with tag **HAM_TOL**.
10<sup>&minus;5</sup> or smaller is usually safe.

At this stage the potential independent setup is complete.  

#### Obtain an input density
{::comment}
/docs/outputs/lmf_output/#obtain-an-input-density
{:/comment}

The next step is to generate the potential : for this a density must be given.  **lmf**{: style="color: blue"} tries to read the density
from the density restart file, *rst.pbte*{: style="color: green"}.  The box below indicates that **lmf**{: style="color: blue"} was not able
to find the file, and instead constructs a trial density by overlapping free atom densities:

~~~
 lmfp  : no rst file ... try to overlap atomic densities
 rdovfa: read and overlap free-atom densities (mesh density) ...
 rdovfa: expected Pb,      read Pb       with rmt=  3.0448  mesh   497  0.025
 rdovfa: expected Te,      read Te       with rmt=  3.0287  mesh   461  0.025
~~~

If you have 


{::nomarkdown}</div>{:/}

