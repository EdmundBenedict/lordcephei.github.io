---
layout: page-fullwidth
title: "Annotated standard output, program lmf"
subheadline: ""
show_meta: false
teaser: ""
permalink: "/docs/outputs/lmf_output/"
header: no
---

_____________________________________________________________

### _Purpose_
{:.no_toc}

This page details the output generated by the band program **lmf**{: style="color: blue"}.

_____________________________________________________________

### _Table of Contents_
{:.no_toc}
*  Auto generated table of contents
{:toc}

The output documented here is mostly taken from the **lmf**{: style="color: blue"}
[tutorial for PbTe](/tutorial/lmf/lmf_pbte_tutorial/).
Some portions are adapted from other calculations, as will be indicated.

The standard output is organised by blocks.  The sections below
annotate each block approximately in the order they are made.

### _Preprocessor's transformation of the input file_
{::comment}
/docs/outputs/lmf_output/#preprocessors-transformation-of-the-input-file
{:/comment}

The input file is run through the [preprocessor](/docs/input/preprocessor/), which modifies the ctrl file before it  is parsed for tags.
Normally it does this silently.  To see the effects of the preprocessor use `lmf --showp ...`

<div onclick="elm = document.getElementById('preprocessor'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<button type="button" class="button tiny radius">Click here to see the action of the preprocessor on ctrl.pbte.</button>
</div>{::nomarkdown}<div style="display:none;padding:0px;"id="preprocessor">{:/}
{::comment}
<span style="text-decoration:underline;">Click here to see the action of the preprocessor on ctrl.pbte.</span>
{:/comment}

Append `--showp` to the **lmf**{: style="color: blue"} command in the [PbTe tutorial](/tutorial/lmf/lmf_pbte_tutorial/#/tutorial/lmf/lmf_pbte_tutorial/#self-consistency)


~~~
$ lmf ctrl.pbte -vnkabc=6 -vgmax=7.8 --showp
~~~
The box below compares side by side the original _ctrl.pbte_{: style="color: green"}
and its transformation by the preprocessor (the original file was edited slightly)

~~~
% const nit=10
% const met=5
% const so=0 nsp=so?2:1
% const lxcf=2 lxcf1=0 lxcf2=0
% const pwmode=0 pwemax=3
% const nkabc=0 gmax=0

VERS  LM:7 FP:7 # ASA:7                          |  VERS  LM:7 FP:7
IO    SHOW=f HELP=f IACTIV=f VERBOS=35,35        |  IO    SHOW=f HELP=f IACTIV=f VERBOS=35,35
EXPRESS                                          |  EXPRESS
# Lattice vectors and site positions             |
  file=   site                                   |    file=   site
                                                 |
# Basis set                                      |
  gmax=   {gmax}                                 |    gmax=   7.8
  autobas[pnu=1 loc=1 lmto=5 mto=4 gw=0]         |    autobas[pnu=1 loc=1 lmto=5 mto=4 gw=0]
                                                 |
# Self-consistency                               |
  nit=    {nit}                                  |    nit=    10
  mix=    B2,b=.3,k=7                            |    mix=    B2,b=.3,k=7
  conv=   1e-5                                   |    conv=   1e-5
  convc=  3e-5                                   |    convc=  3e-5
                                                 |
# Brillouin zone                                 |
  nkabc=  {nkabc}                                |    nkabc=  6
  metal=  {met}                                  |    metal=  5
                                                 |
# Potential                                      |
  nspin=  {nsp}                                  |    nspin=  1
  so=     {so}                                   |    so=     0
  xcfun=  {lxcf},{lxcf1},{lxcf2}                 |    xcfun=  2,0,0
                                                 |
#SYMGRP i*r3(1,1,-1) r4x                         |
HAM                                              |  HAM
    PWMODE={pwmode} PWEMIN=0 PWEMAX={pwemax}     |      PWMODE=0 PWEMIN=0 PWEMAX=3
    FORCES={so==0} ELIND=-0.7                    |      FORCES=1 ELIND=-0.7
SPEC                                             |  SPEC
  ATOM=Pb  Z= 82  R= 3.044814  LMX=3  LMXA=4     |    ATOM=Pb  Z= 82  R= 3.044814  LMX=3  LMXA=4
  ATOM=Te  Z= 52  R= 3.028689  LMX=3  LMXA=3     |    ATOM=Te  Z= 52  R= 3.028689  LMX=3  LMXA=3
~~~

{::nomarkdown}</div>{:/}

### _Display tags parsed in the input file_
{::comment}
/docs/outputs/lmf_output/#display-tags-parsed-in-the-input-file
{:/comment}

After transformation by the preprocessor, **lmf**{: style="color: blue"} parses for tags and substitutes default values for tags it does not
find.  To see the value of tags **lmf**{: style="color: blue"}, whether parsed or defaults, use `lmf --show` or `lmf --show=2`.  The latter causes **lmf**{:
style="color: blue"} to stop after displaying tags, and is useful if you want to see whether **lmf**{: style="color: blue"} is doing what
you expect.  Using `--show` is useful if you want to record the input conditions in the output (be advised that the output is verbose).

<div onclick="elm = document.getElementById('tags'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<button type="button" class="button tiny radius">Click here to see --show explained.</button>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="tags">{:/}
{::comment}
<span style="text-decoration:underline;">Click here to see --show explained.</span>
{:/comment}

Add `--show=2` to the **lmf**{: style="color: blue"} command from the PbTe tutorial:

~~~
$ lmf ctrl.pbte -vnkabc=6 -vgmax=7.8 --show=2
~~~
The output is quite verbose so only a snippet from the **SPEC** category is shown

~~~
 Tag                    Input   cast  (size,min,read,def)     result

...
 --- Parameters for species data ---
 SPEC_SCLWSR            opt    r8       1,  1,   *,  1  0
 SPEC_OMAX1             opt    r8v      3,  1,   *,  3  0 0 0
 SPEC_HFAC              opt    chr      1,  0,   *
 SPEC_HFAC_V            opt    lg       1,  1,   *,  1  F
 ... Species 1
 SPEC_ATOM              reqd   chr      1,  0,   1      Pb
 SPEC_ATOM_Z            reqd   r8       1,  1,   1, --  82
 SPEC_ATOM_R            reqd*  r8       1,  1,   1, --  3.04481
 SPEC_ATOM_A            opt    r8       1,  1,   *,  1  0.025
 SPEC_ATOM_NR           opt    i4       1,  1,   *,  1  497
 SPEC_ATOM_RSMH         opt    r8v      4,  4,   *,  4  0 0 0 0
 SPEC_ATOM_EH           opt    r8v      4,  4,   *, --
...
~~~

*  Tags are optional except for **SPEC_ATOM**, **SPEC_ATOM_Z**, and **SPEC_ATOM_R**;
   the latter _could_ have been supplied with equivalent information through a different tag
   (**SPEC_ATOM_R/W** or **SPEC_ATOM_R/A) in this case.
*  Variables are read as scalars or vectors; integers, floating-point numbers, or strings.
   If strings have spaces you must enclose them in quotes or backets.
*  Default values were substituted for the optional tags.  In this case, the input
   file contained none of the optional tags: all values are taken from defaults,
   except for **EH** which was not assigned any value.
   **lmf**{: style="color: blue"} requires **EH**; but it will be read independently
   from the basp file.

{::nomarkdown}</div>{:/}

There are two other special modes to help with managing the input.

`$lmf --input` doesn't attempt to read anything; instead, it prints out a (large) table of all the tags it would try to read, including a brief description of the tag, and then exits.  See [here](/docs/input/inputfile/#help-with-finding-tokens) for further description.

`$ lmf --help` performs a similar function for the command line arguments: it prints out a brief summary of arguments effective in the executable you are using.
See [the tutorial](/tutorial/lmf/lmf_pbte_tutorial/#determining-what-input-an-executable-seeks)
for further description.

###  _Reading basis information from the basp file_
{::comment}
/docs/outputs/lmf_output/#reading-basis-information-from-the-basp-file
{:/comment}

After parsing the ctrl file, **lmf**{: style="color: blue"} may attempt to read
basis set information from the basp file.\\
The basp file is [automatically generated](/tutorial/lmf/lmf_pbte_tutorial/#automatic-determination-of-basis-set)
by **lmfa**{: style="color: blue"}.  Tokens in
**EXPRESS_autobas** or **HAM_AUTOBAS**  control what is read from the basp file.

<div onclick="elm = document.getElementById('basp'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for a description.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="basp">{:/}

{::comment}
text underlined:
<span style="text-decoration:underline;">Click here for a description.</span>
nothing:
Click here for a description.
{:/comment}

_basp.pbte_{: style="color: green"} supplies basis information (parameters **EH** and **RSMH** defining the shape of the envelope functions,
["continuous principal quantum numbers](/docs/code/asaoverview/#augmentation-sphere-boundary-conditions-and-continuous-principal-quantum-numbers) _P_
and information about local orbitals).

~~~
 rdctrl: reading basis parameters from file basp
 ioorbp: read species Pb        RSMH,EH RSMH2,EH2 P PZ
 ioorbp: read species Te        RSMH,EH RSMH2,EH2 P
         reset nkaph from 1 to 3
~~~

You can also supply this information in the ctrl file.
If both are present **lmf**{: style="color: blue"} decides on which to
use depending on settings in **EXPRESS_autobas** or **HAM_AUTOBAS**

To see a synopsis of tokens in **AUTOBAS**,
[invoke `lmf --input`](/docs/input/inputfile/#help-with-finding-tokens-the---input-switch)
and search for **autobas**.  Tokens in **AUTOBAS are documented [here](/docs/input/inputfile/#ham).

{::nomarkdown}</div>{:/}

### _Header information_
{::comment}
/docs/outputs/lmf_output/#header-information
{:/comment}

The header information presents a condensed synopsis of some key
settings that are used in the calculation.

~~~
 LMF:      nbas = 2  nspec = 2  vn 7.11.i  verb 35
 special:  forces
 pot:      XC:BH
 float:    float P LDA-style
 autoread: mto basis(4), pz(1), pnu(1)
 bz:       metal(5), tetra, invit
~~~

### _Lattice information_
{::comment}
/docs/outputs/lmf_output/#lattice-information
{:/comment}

This block prints informations about the lattice vectors and settings used in Ewald summations:

~~~
                Plat                                  Qlat
   0.000000   0.500000   0.500000       -1.000000   1.000000   1.000000
   0.500000   0.000000   0.500000        1.000000  -1.000000   1.000000
   0.500000   0.500000   0.000000        1.000000   1.000000  -1.000000
   alat = 12.147006  Cell vol = 448.071898

 LATTC:  as= 2.000   tol=1.00E-08   alat=12.14701   awald= 0.261
         r1=  1.807   nkd= 87       q1=  5.403   nkg= 169
~~~

_Note:_{: style="color: red"} When long, thin cells are used, or when APW's are added to the basis set, some attention needs to be paid to the Ewald tolerance,
input through [**EWALD\_TOL**](/docs/input/inputfile/#ewald).

### _Symmetry and k mesh_
{::comment}
/docs/outputs/lmf_output/#symmetry-and-k-mesh
{:/comment}

The block below shows symmetry operations it finds in the
crystal, and the irreducible k mesh it obtains from the point group it is given:

~~~
 SGROUP: 1 symmetry operations from 0 generators
 SYMLAT: Bravais system is cubic with 48 symmetry operations.
 SYMCRY: crystal invariant under 48 symmetry operations for tol=1e-5
 GROUPG: the following are sufficient to generate the space group:
         i*r3(1,1,-1) r4x
         i*r3(1,1,-1) r4x
 MKSYM:  found 48 space group operations ... includes inversion
 BZMESH:  16 irreducible QP from 216 ( 6 6 6 )  shift= F F F
 TETIRR: sorting 1296 tetrahedra ... 35 inequivalent ones found
~~~

_Notes:_{: style="color: red"} (see also ["Additional Exercises"](/tutorial/lmf/lmf_pbte_tutorial/#additional-exercises))

+ The group operations were determined automatically from the given lattice.  PbTe is cubic, with 48 group operations.\\
  First the crystal system is determined; then the symmetry operations inconsistent with the basis are discarded.\\
  Finally the operations are distilled into a minimum set of generators **(i*r3(1,1,-1) r4x**) that make the entire group.
  In this case there are no translations; all the group operators are pure rotations, specified with [this syntax](/docs/misc/rotations).
  This is not true in general; for example hcp Co has 24 space group operations.  If one atom is at the origin the generators
  defining the group can be written as the following set of (point group + translation):

      i*r3z::(1/3,-1/3,-1/2) r2z::(1/3,-1/3,1/2) r2x

  see the [SYMGRP](/lordcephei.github.io/docs/input/inputfile/#symgrp) category for syntax.

+ You can also specify symmetry operations [manually](/lordcephei.github.io/docs/input/inputfile/#symgrp).  This is particularly useful when magnetic symmetry must be considered.
+ The _k_ mesh is specifed through the number of divisions along each of the three reciprocal lattice vectors, tag **EXPRESS_nabc** or [**BZ_NABC**](/docs/input/inputfile/#bz).\\
  You can also specify whether the k-mesh should pass through the origin or straddle it
  through tag [**BZ_BZJOB**](/docs/input/inputfile/#bz).
+ The Brillouin zone integration is using Bloechl's generalized tetrahedron method.
  You can also use the Methfessel-Paxton integration scheme or a Fermi function.





### _Augmentation parameters_
{::comment}
/docs/outputs/lmf_output/#augmentation-parameters
{:/comment}

The table below contains a synopsis of key parameters associated with augmentation spheres.

~~~
 species data:  augmentation                           density
 spec       rmt   rsma lmxa kmxa      lmxl     rg   rsmv  kmxv foca   rfoca
 Pb       3.045  1.218    4    3         4  0.761  1.522    15    1   1.218
 Te       3.029  1.211    3    3         3  0.757  1.514    15    1   1.211
~~~

+ **rmt** is the augmentation radius
+ **rsma** and **kmxa** are the smoothing radius and polynomial order used to expand envelope function around other sites.
+ **lmxa** is the _l_-cutoff of the augmentation.  Because of the unique way augmentation is done in this method, **lmxa** can be much lower standard augmented wave methods require
+ **lmxl** is analogous to **lmxa**, but it controls the _l_-cutoff of the charge density.
  **lmxl** defaults to **lmxa**; you can often make it smaller with minimal loss of accuracy.  There is little efficiency gain, however.
+ **rg**, **rsmv**, **kmxv** are concerned with adding local gaussian pseudocharges to manage the Hartree potential.
+ **foca**, **rfoca** allow for differing treatments of the core.

### _Interstitial mesh_
{::comment}
/docs/outputs/lmf_output/#interstitial-mesh
{:/comment}

The following block is concerned with the mesh used to represent the charge density,
and to evaluate matrix elements of the (unaugmented) envelope functions.
The spacing of the mesh is controlled by the _G_ cutoff ([**7.8** for PbTe](/docs/outputs/lmfa_output/#estimating-the-plane-wave-cutoff-gmax)).

~~~
 MSHSIZ: mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
         generated from gmax = 7.8 a.u. : 3647 vectors of 5832 (62%)

 GVLIST: gmax = 7.8 a.u. created 3647 vectors of 5832 (62%)
         mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
 SGVSYM: 126 symmetry stars found for 3647 reciprocal lattice vectors
~~~

Information about whether this mesh is sufficiently accurate is given
in the table beginning with _sugcut_{: style="color: green"} below.

### _Counting the size of the basis_
{::comment}
/docs/outputs/lmf_output/#counting-the-size-of-the-basis
{:/comment}

In the table below, the size of the basis is presented.
**lmf**{: style="color: blue"} doesn't have downfolding capability, so the
important numbers are those in the "low" column.  Rows 1,2,3 indicate how
many orbitals are connected respectively with the first Hankel envelope (**EH**),
the second envelope (**EH2**), and local orbitals.
The total basis (and hamiltonian rank) consists of 55 orbitals.

~~~
 Makidx:  hamiltonian dimensions Low, Int, High, Negl: 55 0 32 63
 kappa   Low   Int   High  L+I  L+I+H  Neglected
   1      32     0     9    32    41       9
   2      18     0    23    18    41       9
   3       5     0     0     5     5      45
  all     55     0    32    55    87      63
 suham : s 41 augmentation channels, 41 local potential channels  Maximum lmxa=4
~~~

The last line refers to augmentation channels.  An envelope of a particular _l_
must be expanded around remote sites.  The _l_-cutoff for expanding tails of envelope functions centered elsewhere is
**lmxa**, input though tag ope[**SPEC\_ATOM\_LMXA**](/docs/input/inputfile/#spec-cat).
For **lmf**{: style="color: blue"}, **lmxa** is usually reasonably converged if it is
3 for _sp_ systems, 4 for _d_ atoms and 6 for _f_ shell elements.

### _Envelope function parameters and their G cutoffs_
{::comment}
/docs/outputs/lmf_output/#envelope-function-parameters-and-their-g-cutoffs
{:/comment}

In the table envelope function parameters for each species is given,
which defines their shape.   Also shown is :

+  **gmax** : the _G_ cutoff that represents that envelope to the 
   given tolerance
+  **last term** : an estimate for the precision of the plane-wave repesentation
+  **cutoff** : the number of plane waves with _G_<**gmax**.

~~~
 sugcut:  make orbital-dependent reciprocal vector cutoffs for tol=1.0e-6
 spec      l    rsm    eh     gmax    last term   cutoff
  Pb       0    1.80  -0.10   4.123    2.68E-06     531
  Pb       1    2.02  -0.10   3.848    2.42E-06     411
  Pb       2*   2.03  -0.10   4.013    1.37E-06     531
  Pb       3    2.03  -0.10   4.193    1.54E-06     537
  Pb       0    1.80  -0.90   4.123    2.68E-06     531
  Pb       1    2.02  -0.90   3.848    2.42E-06     411
  Pb       2    2.03  -0.90   4.013    1.37E-06     531
  Te       0    1.63  -0.10   4.572    1.45E-06     725
  Te       1    1.71  -0.10   4.575    1.52E-06     725
  Te       2*   2.02  -0.10   4.037    1.63E-06     531
  Te       3    2.02  -0.10   4.218    1.87E-06     537
  Te       0    1.63  -0.90   4.572    1.45E-06     725
  Te       1    1.71  -0.90   4.575    1.52E-06     725
  Te       2    2.02  -0.90   4.037    1.63E-06     531
~~~

Each envelope function must be expanded in plane waves in order to assemble matrix elements of the interstitial potential the output charge
density. Both are assembled in reciprocal space.
The number of plane waves needed for a particular orbital depends on how sharply peaked the function is, so the cutoff is orbital-dependent
to allow for faster execution.
**gmax** of any one orbital may safely be less than the global _G_ cutoff (**7.8** for PbTe); if it can, **lmf**{: style="color: blue"} will
find a **gmax** for each orbital that meets a preset tolerance.  Otherwise it uses all the _G_ vectors available to it, and appends a '\*'
to the number indicating not enough orbitals are available to meet the specified tolerance (10<sup>&minus;6</sup> in this case).

It can happen that some of the orbitals bump up against the global cutoff.  This is flagged by
a &thinsp;<b>*</b>&thinsp; appended to the cutoff, e.g.

~~~
  Te       0    1.63  -0.10   4.572    1.74E-06     701*
~~~

In this case check **last term**.  If it is too high you can expect errors in the hamiltonian and you should increase **gmax**.

The tolerance defaults to 10<sup>&minus;6</sup>, but you can control it with tag **HAM_TOL**.
10<sup>&minus;5</sup> or smaller is usually safe.

_Note:_{: style="color: red"} With APW's also in the basis, it the overlap matrix becomes nearly singular.
To stabilize the overlap matrix, you can set **HAM_TOL** to something close to machine precision

At this stage the potential independent setup is complete.

### _Obtain an input density_
{::comment}
(/docs/outputs/lmf_output/#obtain-an-input-density)
{:/comment}

The next step is to generate the potential : for this a density must be given.  **lmf**{: style="color: blue"} tries to read the density
from the density restart file, *rst.pbte*{: style="color: green"}.  The box below indicates that **lmf**{: style="color: blue"} was not able
to find the file, and instead constructs a trial density by overlapping free atom densities.

**lmf**{: style="color: blue"} reads atomic densities from [*atm.pbte*{: style="color: green"}](/docs/outputs/lmfa_output/#summary)
and overlaps them (Mattheis construction).  This makes a reasonable guessed density.

{::nomarkdown} <a name="mattheis-construction"></a> {:/}
{::comment}
(/docs/outputs/lmf_output/#mattheis-construction)
{:/comment}

<div onclick="elm = document.getElementById('mattheis'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for annotation of Mattheis construction printout.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="mattheis">{:/}

This table indicates what **lmf**{: style="color: blue"} is doing, and checks
that *atm.pbte*{: style="color: green"} is consistent the input file.

~~~
 lmfp  : no rst file ... try to overlap atomic densities
 rdovfa: read and overlap free-atom densities (mesh density) ...
 rdovfa: expected Pb,      read Pb       with rmt=  3.0448  mesh   497  0.025
 rdovfa: expected Te,      read Te       with rmt=  3.0287  mesh   461  0.025
~~~

Next follows a table with some useful information about the overlapping process

~~~
 ovlpfa: overlap smooth part of FA densities
 site   1  spec  1  pos  0.0000  0.0000  0.0000  Qsmooth 7.659845
 site   2  spec  2  pos  0.0000  0.0000  0.5000  Qsmooth 7.820498
 total smooth Q = 15.480342

 Free atom and overlapped crystal site charges:
   ib    true(FA)    smooth(FA)  true(OV)    smooth(OV)    local
    1   12.535727    6.195571   12.881552    6.541397    6.340155
    2    4.566605    6.387103    4.926059    6.746557   -1.820498

 Smooth charge on mesh:           15.480342
 Sum of local charges:             4.519657
 Total valence charge:            20.000000
 Sum of core charges:            114.000000
 Sum of nuclear charges:        -134.000000
 Homogeneous background:           0.000000
 Deviation from neutrality:       -0.000000
~~~

It is important that the system is charge neutral (last line).

{::nomarkdown}</div>{:/}

If, on the other hand, the charge density has been saved in a restart file,
**lmf**{: style="color: blue"} reads it.  Usually restart files are
saved in a binary form in a file named *rst.ext*{: style="color: green"}.

<div onclick="elm = document.getElementById('rdrst'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here to see and control what lmf reads from and writes to the restart file.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="rdrst">{:/}

When **lmf**{: style="color: blue"} reads from a restart file it prints out
a message similar to this:

~~~
 iors  : read restart file (binary, mesh density) 
         use from  restart file: ef window, positions, pnu 
         ignore in restart file: *
~~~

The restart file contains:

+ Information about the Fermi level and (in the sampling case) parameters
that were used to assemble the density from a Brillouin zone integration
+ lattice vectors and site positions
+ boundary conditions for partial waves, kept as logarithmic derivative parameters (also called [continuous principal quantum numbers](/docs/code/asaoverview/#augmentation-sphere-boundary-conditions-and-continuous-principal-quantum-numbers)
+ valence and core densities inside augmentation spheres
+ mesh density

{::nomarkdown}</div>{:/}


xxx

