---
layout: page-fullwidth
title: "Annotated standard output, program lmf"
subheadline: ""
show_meta: false
teaser: ""
permalink: "/docs/outputs/lmf_output/"
header: no
---

_____________________________________________________________

### _Purpose_
{:.no_toc}

This page details the output generated by the band program **lmf**{: style="color: blue"}.

_____________________________________________________________

### _Table of Contents_
{:.no_toc}
*  Auto generated table of contents
{:toc}

The output documented here is mostly taken from the **lmf**{: style="color: blue"}
[tutorial for PbTe](/tutorial/lmf/lmf_pbte_tutorial/).
Some portions are adapted from other calculations, as will be indicated.

The standard output is organised by blocks.  Each section below
explains a block approximately in the order they are made.

### Preprocessor's transformation of the input file
{::comment}
/docs/outputs/lmf_output/#preprocessors-transformation-of-the-input-file
{:/comment}

The input file is run through the [preprocessor](/docs/input/preprocessor/), which modifies the ctrl file before it it is parsed for tags.
Normally it does this silently.  To see the effects of the preprocessor use `lmf --showp ...`

<div onclick="elm = document.getElementById('preprocessor'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here to see the action of the preprocessor on ctrl.pbte.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;"id="preprocessor">{:/}
{::comment}
<button type="button" class="button tiny radius">Click here to see the action of the preprocessor on ctrl.pbte.</button>
{:/comment}

Append `--showp` to the **lmf**{: style="color: blue"} command in the [PbTe tutorial](/tutorial/lmf/lmf_pbte_tutorial/#/tutorial/lmf/lmf_pbte_tutorial/#self-consistency)


~~~
$ lmf ctrl.pbte -vnkabc=6 -vgmax=7.8 --showp
~~~
The box below compares side by side the original _ctrl.pbte_{: style="color: green"}
and its transformation by the preprocessor (the original file was edited slightly)

~~~
% const nit=10
% const met=5
% const so=0 nsp=so?2:1
% const lxcf=2 lxcf1=0 lxcf2=0
% const pwmode=0 pwemax=3
% const nkabc=0 gmax=0

VERS  LM:7 FP:7 # ASA:7                          |  VERS  LM:7 FP:7
IO    SHOW=f HELP=f IACTIV=f VERBOS=35,35        |  IO    SHOW=f HELP=f IACTIV=f VERBOS=35,35
EXPRESS                                          |  EXPRESS
# Lattice vectors and site positions             |
  file=   site                                   |    file=   site
                                                 |
# Basis set                                      |
  gmax=   {gmax}                                 |    gmax=   7.8
  autobas[pnu=1 loc=1 lmto=5 mto=4 gw=0]         |    autobas[pnu=1 loc=1 lmto=5 mto=4 gw=0]
                                                 |
# Self-consistency                               |
  nit=    {nit}                                  |    nit=    10
  mix=    B2,b=.3,k=7                            |    mix=    B2,b=.3,k=7
  conv=   1e-5                                   |    conv=   1e-5
  convc=  3e-5                                   |    convc=  3e-5
                                                 |
# Brillouin zone                                 |
  nkabc=  {nkabc}                                |    nkabc=  6
  metal=  {met}                                  |    metal=  5
                                                 |
# Potential                                      |
  nspin=  {nsp}                                  |    nspin=  1
  so=     {so}                                   |    so=     0
  xcfun=  {lxcf},{lxcf1},{lxcf2}                 |    xcfun=  2,0,0
                                                 |
#SYMGRP i*r3(1,1,-1) r4x                         |
HAM                                              |  HAM
    PWMODE={pwmode} PWEMIN=0 PWEMAX={pwemax}     |      PWMODE=0 PWEMIN=0 PWEMAX=3
    FORCES={so==0} ELIND=-0.7                    |      FORCES=1 ELIND=-0.7
SPEC                                             |  SPEC
  ATOM=Pb  Z= 82  R= 3.044814  LMX=3  LMXA=4     |    ATOM=Pb  Z= 82  R= 3.044814  LMX=3  LMXA=4
  ATOM=Te  Z= 52  R= 3.028689  LMX=3  LMXA=3     |    ATOM=Te  Z= 52  R= 3.028689  LMX=3  LMXA=3
~~~

{::nomarkdown}</div>{:/}

### Display tags parsed in the input file
{::comment}
/docs/outputs/lmf_output/#display-tags-parsed-in-the-input-file
{:/comment}

To see what tags **lmf**{: style="color: blue"} will look for, use `lmf --input`.
[This web page](/docs/input/inputfile/#help-with-finding-tokens) explains
what `--input` gives you.

After transformation by the preprocessor, **lmf**{: style="color: blue"} parses for tags and substitutes default values for tags it does not
find.  To see the value of tags **lmf**{: style="color: blue"}, whether parsed or defaults, use `lmf --show` or `lmf --show=2`.  The latter causes **lmf**{:
style="color: blue"} to stop after displaying tags, and is useful if you want to see whether **lmf**{: style="color: blue"} is doing what
you expect.  Using `--show` is useful if you want to record the input conditions in the output (be advised that the output is verbose).


<div onclick="elm = document.getElementById('tags'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here to see --show explained.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="tags">{:/}
{::comment}
<button type="button" class="button tiny radius">Click here for an interpretation of the action of --show.</button>
{:/comment}

Add `--show=2` to the **lmf**{: style="color: blue"} command from the PbTe tutorial:

~~~
$ lmf ctrl.pbte -vnkabc=6 -vgmax=7.8 --show=2
~~~
The output is quite verbose so only a snippet from the **SPEC** category is shown

~~~
 Tag                    Input   cast  (size,min,read,def)     result

...
 --- Parameters for species data ---
 SPEC_SCLWSR            opt    r8       1,  1,   *,  1  0
 SPEC_OMAX1             opt    r8v      3,  1,   *,  3  0 0 0
 SPEC_HFAC              opt    chr      1,  0,   *
 SPEC_HFAC_V            opt    lg       1,  1,   *,  1  F
 ... Species 1
 SPEC_ATOM              reqd   chr      1,  0,   1      Pb
 SPEC_ATOM_Z            reqd   r8       1,  1,   1, --  82
 SPEC_ATOM_R            reqd*  r8       1,  1,   1, --  3.04481
 SPEC_ATOM_A            opt    r8       1,  1,   *,  1  0.025
 SPEC_ATOM_NR           opt    i4       1,  1,   *,  1  497
 SPEC_ATOM_RSMH         opt    r8v      4,  4,   *,  4  0 0 0 0
 SPEC_ATOM_EH           opt    r8v      4,  4,   *, --
...
~~~

*  Tags are optional except for **SPEC_ATOM**, **SPEC_ATOM_Z**, and **SPEC_ATOM_R**;
   the latter _could_ have been supplied with equivalent information through a different tag
   (**SPEC_ATOM_R/W** or **SPEC_ATOM_R/A) in this case.
*  Variables are read as scalars or vectors; integers, floating-point numbers, or strings.
   If strings have spaces you must enclose them in quotes or backets.
*  Default values were substituted for the optional tags.  In this case, the input
   file contained none of the optional tags: all values are taken from defaults,
   except for **EH** which was not assigned any value.
   **lmf**{: style="color: blue"} requires **EH**; but it will be read independently
   from the basp file.

{::nomarkdown}</div>{:/}

###  Reading basis information from the basp file
{::comment}
/docs/outputs/lmf_output/#reading-basis-information-from-the-basp-file
{:/comment}

After parsing the ctrl file, **lmf**{: style="color: blue"} may attempt to read
basis set information from the basp file.\\
The basp file is [automatically generated](/tutorial/lmf/lmf_pbte_tutorial/#automatic-determination-of-basis-set)
by **lmfa**{: style="color: blue"}.  Tokens in
**EXPRESS_autobas** or **HAM_AUTOBAS**  control what is read from the basp file.

something wrong ... try2

<div onclick="elm = document.getElementById('basp'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for a description.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="basp">{:/}

{::comment}
...problem here
<div onclick="elm = document.getElementById('basp'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for a description.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id=" basp">{:/}


text underlined:
<span style="text-decoration:underline;">Click here for a description.</span>
nothing:
Click here for a description.
{:/comment}

_basp.pbte_{: style="color: green"} supplies basis information (parameters **EH** and **RSMH** defining the shape of the envelope functions,
["continuous principal quantum numbers](/docs/code/asaoverview/#augmentation-sphere-boundary-conditions-and-continuous-principal-quantum-numbers) _P_
and information about local orbitals).

~~~
 rdctrl: reading basis parameters from file basp
 ioorbp: read species Pb        RSMH,EH RSMH2,EH2 P PZ
 ioorbp: read species Te        RSMH,EH RSMH2,EH2 P
         reset nkaph from 1 to 3
~~~

You can also supply this information in the ctrl file.
If both are present **lmf**{: style="color: blue"} decides on which to
use depending on settings in **EXPRESS_autobas** or **HAM_AUTOBAS**

To see a synopsis of tokens in **AUTOBAS**,
[invoke `lmf --input`](/docs/input/inputfile/#help-with-finding-tokens-the---input-switch)
and search for **autobas**.  Tokens in **AUTOBAS are documented [here](/docs/input/inputfile/#ham).

{::nomarkdown}</div>{:/}

### Header information
{::comment}
/docs/outputs/lmf_output/#header-information
{:/comment}

The header information presents a condensed synopsis of some key
settings that are used in the calculation.

~~~
 LMF:      nbas = 2  nspec = 2  vn 7.11.i  verb 35
 special:  forces
 pot:      XC:BH
 float:    float P LDA-style
 autoread: mto basis(4), pz(1), pnu(1)
 bz:       metal(5), tetra, invit
~~~

### Lattice information
{::comment}
/docs/outputs/lmf_output/#lattice-information
{:/comment}

This block prints informations about the lattice vectors and settings used in Ewald summations:

~~~
                Plat                                  Qlat
   0.000000   0.500000   0.500000       -1.000000   1.000000   1.000000
   0.500000   0.000000   0.500000        1.000000  -1.000000   1.000000
   0.500000   0.500000   0.000000        1.000000   1.000000  -1.000000
   alat = 12.147006  Cell vol = 448.071898

 LATTC:  as= 2.000   tol=1.00E-08   alat=12.14701   awald= 0.261
         r1=  1.807   nkd= 87       q1=  5.403   nkg= 169
~~~

_Note:_{: style="color: red"} When long, thin cells are used, or when APW's are added to the basis set, some attention needs to be paid to the Ewald tolerance.

### Symmetry and k mesh
{::comment}
/docs/outputs/lmf_output/#symmetry-and-k-mesh
{:/comment}

The block below shows symmetry operations it finds in the
crystal, and the irreducible k mesh it obtains from the point group it is given:

~~~
 SGROUP: 1 symmetry operations from 0 generators
 SYMLAT: Bravais system is cubic with 48 symmetry operations.
 SYMCRY: crystal invariant under 48 symmetry operations for tol=1e-5
 GROUPG: the following are sufficient to generate the space group:
         i*r3(1,1,-1) r4x
         i*r3(1,1,-1) r4x
 MKSYM:  found 48 space group operations ... includes inversion
 BZMESH:  16 irreducible QP from 216 ( 6 6 6 )  shift= F F F
 TETIRR: sorting 1296 tetrahedra ... 35 inequivalent ones found
~~~

Notes: (see also "Additional Exercises" below)

+ You can specify symmetry operations manually.  This is particularly useful
  when magnetic symmetry must be considered.
+ The k mesh is specifed through the number of k divisions along each of the three reciprocal lattice vectors, tag **EXPRESS_nabc**.\\
  You can also specify whether the k-mesh should pass through the origin or straddle it
  through tag **BZ_BZJOB**.
+ The Brillouin zone integration is using Bloechl's generalized tetrahedron method.
  You can also use the Methfessel-Paxton integration scheme or a Fermi function.

### Augmentation parameters
{::comment}
/docs/outputs/lmf_output/#augmentation-parameters
{:/comment}

The table below contains a synopsis of key parameters associated with augmentation spheres.

~~~
 species data:  augmentation                           density
 spec       rmt   rsma lmxa kmxa      lmxl     rg   rsmv  kmxv foca   rfoca
 Pb       3.045  1.218    4    3         4  0.761  1.522    15    1   1.218
 Te       3.029  1.211    3    3         3  0.757  1.514    15    1   1.211
~~~

+ **rmt** is the augmentation radius
+ **rsma** and **kmxa** are the smoothing radius and polynomial order used to expand envelope function around other sites.
+ **lmxa** is the _l_-cutoff of the augmentation.  Because of the unique way augmentation is done in this method, **lmxa** can be much lower standard augmented wave methods require
+ **lmxl** is analogous to **lmxa**, but it controls the _l_-cutoff of the charge density.  **lmxl** defaults to **lmxa**; you can often make it smaller with minimal loss of accuracy.
+ **rg**, **rsmv**, **kmxv** are concerned with adding local gaussian pseudocharges to manage the Hartree potential.
+ **foca**, **rfoca** allow for differing treatments of the core.

### Interstitial mesh
{::comment}
/docs/outputs/lmf_output/#interstitial-mesh
{:/comment}

The following block is concerned with the mesh used to represent the charge density,
and to evaluate matrix elements of the (unaugmented) envelope functions
The spacing of the mesh is controlled by the _G_ cutoff (**7.8** for PbTe).

~~~
 MSHSIZ: mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
         generated from gmax = 7.8 a.u. : 3647 vectors of 5832 (62%)

 GVLIST: gmax = 7.8 a.u. created 3647 vectors of 5832 (62%)
         mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
 SGVSYM: 126 symmetry stars found for 3647 reciprocal lattice vectors
~~~

Information about whether this mesh is sufficiently accurate is given
in the table beginning with _sugcut_{: style="color: green"} below.

### Counting the size of the basis
{::comment}
/docs/outputs/lmf_output/#counting-the-size-of-the-basis
{:/comment}

In the table below, the size of the basis is presented.
**lmf**{: style="color: blue"} doesn't have downfolding capability, so the
important numbers are those in the "low" column.  Rows 1,2,3 indicate how
many orbitals are connected respectively with the first Hankel envelope (**EH**),
the second envelope (**EH2**), and local orbitals.
The total basis (and hamiltonian rank) consists of 55 orbitals.

~~~
 Makidx:  hamiltonian dimensions Low, Int, High, Negl: 55 0 32 63
 kappa   Low   Int   High  L+I  L+I+H  Neglected
   1      32     0     9    32    41       9
   2      18     0    23    18    41       9
   3       5     0     0     5     5      45
  all     55     0    32    55    87      63
 suham :  41 augmentation channels, 41 local potential channels  Maximum lmxa=4
~~~

### Envelope function parameters and their G cutoffs
{::comment}
/docs/outputs/lmf_output/#envelope-function-parameters-and-their-g-cutoffs
{:/comment}

In the table envelope function parameters for each species is given,
which defines their shape.   Also shown is an orbital-dependent **gmax**.

~~~
 sugcut:  make orbital-dependent reciprocal vector cutoffs for tol=1.0e-6
 spec      l    rsm    eh     gmax    last term   cutoff
  Pb       0    1.80  -0.10   4.123    2.68E-06     531
  Pb       1    2.02  -0.10   3.848    2.42E-06     411
  Pb       2*   2.03  -0.10   4.013    1.37E-06     531
  Pb       3    2.03  -0.10   4.193    1.54E-06     537
  Pb       0    1.80  -0.90   4.123    2.68E-06     531
  Pb       1    2.02  -0.90   3.848    2.42E-06     411
  Pb       2    2.03  -0.90   4.013    1.37E-06     531
  Te       0    1.63  -0.10   4.572    1.45E-06     725
  Te       1    1.71  -0.10   4.575    1.52E-06     725
  Te       2*   2.02  -0.10   4.037    1.63E-06     531
  Te       3    2.02  -0.10   4.218    1.87E-06     537
  Te       0    1.63  -0.90   4.572    1.45E-06     725
  Te       1    1.71  -0.90   4.575    1.52E-06     725
  Te       2    2.02  -0.90   4.037    1.63E-06     531
~~~

Each envelope function must be expanded in plane waves in order to assemble matrix elements of the interstitial potential
the output charge density.
Both are assembled in reciprocal space.
The number of plane waves needed for a particular orbital depends on how sharply peaked the function is,
so the cutoff is orbital-dependent to allow for faster execution.
**gmax** of any one orbital may safely be less than the global _G_ cutoff (**7.8** for PbTe);
if it can, **lmf**{: style="color: blue"} will find a **gmax** for each orbital
that meets a preset tolerance.  Otherwise it uses all the _G_ vectors available to it, and appends a '\*' to the number indicating
not enough orbitals are available to meet the specified tolerance (10<sup>&minus;6</sup> in this case).

If any of the orbitals bump up against the maximum, check the error estimate ("last term") in the Table.
If it is too high you can expect errors in the hamiltonian and you should increase **gmax**.

The tolerance defaults to 10<sup>&minus;6</sup>, but you can control it with tag **HAM_TOL**.
10<sup>&minus;5</sup> or smaller is usually safe.

At this stage the potential independent setup is complete.

### Obtain an input density
{::comment}
/docs/outputs/lmf_output/#obtain-an-input-density
{:/comment}

The next step is to generate the potential : for this a density must be given.  **lmf**{: style="color: blue"} tries to read the density
from the density restart file, *rst.pbte*{: style="color: green"}.  The box below indicates that **lmf**{: style="color: blue"} was not able
to find the file, and instead constructs a trial density by overlapping free atom densities:

~~~
 lmfp  : no rst file ... try to overlap atomic densities
 rdovfa: read and overlap free-atom densities (mesh density) ...
 rdovfa: expected Pb,      read Pb       with rmt=  3.0448  mesh   497  0.025
 rdovfa: expected Te,      read Te       with rmt=  3.0287  mesh   461  0.025
~~~

If you have


{::nomarkdown}</div>{:/}
