---
layout: page-fullwidth
title: "lmgf Documentation"
subheadline: ""
show_meta: false
teaser: ""
permalink: "/docs/lmgf/lmgf-documentation/"
header: no
---

### _Table of Contents_
{:.no_toc}
*  Auto generated table of contents
{:toc} 

### _Purpose_
_____________________________________________________________

This package implements the ASA local spin-density approximation using Green's functions. The Green's functions are contructed by approximating KKR multiple-scattering theory with an analytic potential function. The approximation to KKR is essentially similar to the linear approximation employed in band methods such as LMTO and LAPW. It can be shown that this approximation is nearly equivalent to the LMTO hamiltonian without the "combined correction" term. With this package a new program, **lmgf**{: style="color: blue"} is added to the suite of executables. **lmgf**{: style="color: blue"} plays approximately the same role as the LMTO-ASA band program **lm**{: style="color: blue"}: a potential is generated from energy moments $$Q_0$$, $$Q_1$$, and $$Q_2$$ of the density of states. in the same way as the **lm**{: style="color: blue"} code. You can use **lmgf**{: style="color: blue"} to make a self-consistent density as you can do with **lm**{: style="color: blue"}. lmgf is a Green's function method: Green's functions have less information than wave functions, so in one sense the things you can do with lmgf are more limited: you cannot make the bands directly, for example. However **lmgf**{: style="color: blue"} enables you do do things you cannot do with **lm**{: style="color: blue"}. The two most imprortant are:

+ Calculate magnetic exchange interactions 
+ Calculate magnetic susceptibility (spin-spin, spin-orbit, orbit-orbit parts)
+ Calculate properties of disordered materials, either chemically disordered or spin disorder from finite temperature, within the Coherent Potential Approximation, or CPA.
+ Calculate the ASA static susceptibility at $$q=0$$ to help converge calculations to self-consistency. 


### _Structure of Green's function program_
_____________________________________________________________

**lmgf**{: style="color: blue"} runs in much the same way as program **lm**{: style="color: blue"}. The band pass routine of **lm**{: style="color: blue"}, **bndasa.f**{: style="color: green"}, generates the eigenvalues and eigenvectors, which can in turn generate the quantities of interest. **bndasa**{: style="color: green"} is replaced by a Green's function routine, **gfasa**{: style="color: green"}. **gfasa**{: style="color: green"} can generate output moments, DOS, density-matrix, etc., in the same way as **bndasa**{: style="color: green"} does.

In contrast to band methods (implemented in **lm**{: style="color: blue"}) where the Hamiltonian H is energy independent and all the bands are generated by diagonalizing H, Green's functions are calculated for a specific energy; information is extracted from G for a particular energy.

This fact highlights the strengths and weaknesses of a Green's function approach. Energy-integrated properties such as the moments, must be obtained by integrating over energy. Calculating G explicitly at a family of energies is more cumbersome than diaonalizing a hamiltonian. On the other hand, Green's function methods are naturally suited to contexts where the energy-dependence is needed anyway. CPA theory yields an energy-dependent potential; Green's functions are natural way to implement it. Similarly, noninteracting susceptibilities can be expressed as G×G (`×' implies either convolution or product depending on the space you are working in).

**lmgf**{: style="color: blue"} always loops over some energy contour; what contour you use depends on the context as described below. **gfasa**{: style="color: green"} accumulates various kinds of data for each mesh point, such as the point's contribution from energy moments used in an ASA self-consistent cycle. Finally an estimate for the Fermi level $$E_F$$ is determined using a from Pade approximation. If the original guess for $$E_F$$ is sufficiently close, the cycle is finished as in program **lm**{: style="color: blue"}. If the estimate is too far off, a new energy mesh is taken and the process repeated. 

### _Energy Contours, Potential Shifts and the Determination of the Fermi Level_
_____________________________________________________________

For energy-integrated properties, a very fine energy mesh would be required if the energy integration were carried out close to the real axis. It is much more efficient to deform the integration contour is deformed into an elliptical path in the complex plane, approaching the real axis only at the lower and upper integration limits.

To integrate quantities over occupied states, integration to the Fermi level $$E_F$$ is required. EF is not known but must be fixed by charge neutrality. Thus $$E_F$$ must be guessed at and iteratively refined until the charge neutrality condition is satisfied. **lmgf**{: style="color: blue"} does not vary $$E_F$$; the user specifies it at the outset. Instead **lmgf**{: style="color: blue"} looks for a constant potential shift that satisfies charge neutrality; this must be searched for iteratively. Both the potential shift and $$E_F$$ are maintained in a file **vshft.ext**{: style="color: green"}. Inspection of **vshft.ext**{: style="color: green"} may look unecessarily complicated; it's because you can use the file to add site-dependent shifts. **vshft.ext**{: style="color: green"} is also used by the layer Green's function code **lmpg**{: style="color: blue"}, which requires extra information about shifts on the left and right leads.

Metals and nonmetals are distinguished in that in the latter case, there is no DOS in the gap and therefore the Fermi level (or potential shift) cannot be specified precisely. 

**Metal case** (set by **BZ_METAL=1**): once the k- and energy-points are summed over and the deviation from charge neutrality is determined, the code will attempt to find the potential shift that fixes charge neutrality. It does this in one of two ways:

+ Using a Pade approximant, **lmgf**{: style="color: blue"} interpolates the diagonal elements of G. The interpolation is used to evaluate the GF on the starting elliptical contour shifted rigidly by a constant, and the shift is iterated until the charge-neutrality condition is satisfied. At this stage, there are two possibilities:

  1\. repeat the integration of G over k and the energy contour with the constant shift added to the potential.
  
  2\. Assume that the Pade-approximant to the diagonal G is a sufficiently good estimate for the actual G.
  
  If the potential shift is larger than a user-specifed tolerance (see padtol in **GF_GFOPTS** below), option 1 is taken and the Pade shift re-evaluated. A new Pade estimate is made for the potential shift requiring charge neutrality, and it is tested once against the user-specified tolerance.
  
  When the shift falls below the tolerance, option 2 is taken and **lmgf**{: style="color: blue"} proceeds to the next step. The user is advised to monitor these shifts and the deviation from charge neutrality.

+ The charge is integrated in a contour near the real axis subsequent to the elliptical contour. In this mode, the determination of the potential shift is accomplished by continuing the integration contour on the real axis starting from the originally estimated Fermi level. A trapezoidal rule is used (or Simpson's rule using a Pade approximate for the midpoint), and new energy points are computed and integrals accumulated until charge neutrality is found. There is no iterative scheme as with the Pade approximation. This option tends to be a little less accurate than the Pade, but somewhat more stable as it is less susceptible to interpolation errors.

One last comment about the METAL case: by default the program will save the potential shift to use in the next iteration. You can suppress this save (see frzvc below), which again can be less accurate, but more stable. In particular if you are working with an insulator where stability can be an issue (determination of the Fermi level is somewhat ill conditioned), a stable procedure is to use this option together with second energy integration scheme described above (the integration contour on the real axis).

**Nonmetal case** (set by **BZ METAL=0**): **lmgf**{: style="color: blue"} will not attempt to shift the potential, or ensure charge neutrality. The user is cautioned to to pay rather closer attention to deviations from charge neutrality. It can happen because of numerical integration errors, or because your assumed Fermi level does not fall within the gap. You can use **METAL=1** even if the material is a nonmetal. 

##### _Some Details concerning how lmgf works internally_
_____________________________________________________________

For each energy point, the BZ integration is accomplished by routine in **gf/gfibz.f**{: style="color: green"}, which loops over all irreducible points, generating the "scattering path operator" g and the corresponding g for all the points in the star of k to generate a properly symmetrized g. Within the ASA, second-generation LMTO, g is converted to proper Green's function G, corresponding to the orthogonal gamma representation by an energy scaling. The scaling is carried out in routine **gf/gfg2g.f**{: style="color: green"}. Next the various integrated quantities sought are assembled (done by **gf/gfidos.f**{: style="color: green"}). The potential shift to satisfy charge neutrality is found, and stored in **vshft.ext**{: style="color: green"}. The I/O is handled by routine **subs/iovshf.f**{: style="color: green"}.

### _GF specific input_
_____________________________________________________________

##### _Energy integration contour_
_____________________________________________________________

Green's functions are always performed on some energy contour, which is discretized into a mesh of points in the complex energy plane. (A description of the various kinds of contours this code uses is documented in the comments to **gf/emesh.f**{: style="color: green"}.) G is "spikey" for energies on the real axis (it has poles where there are eigenstates). To compute energy-integrated properties such as magnetic moments or the static susceptibility, the calculation is most efficiently done by deforming the contour in an ellipse in the complex plane. 

At other times you want properties on the real axis, e.g. density-of-states or spectral functions. You specify the contour in category BZ as:

    EMESH= nz mode emin emax [other args, depending mode]

where

           nz         number of energy points
           mode       specifies the kind of contour; see below
           emin,emax  are the energy window (emax is usually the Fermi level)


Right now there are the following contours:

**mode=0**: a uniform mesh of points between emin and emax, with a constant imaginary component.

    EMESH= nz 0 emin emax Im-z [... + possible args for layer geometry.]
           Im-z is the (constant) imaginary component.

This mode is generally not recommended for self-consistent cycles because the GF has a lot of structure close to the real axis (small Im-z), while shifting off the real axis introduces errors. It is used, however, in other contexts, e.g. transport. 

**mode=10**: a Gaussian quadrature on an ellipse.

    EMESH= nz 10 emin emax ecc eps

           ecc is the eccentricity of the ellipse, 
               ranging from 0 (circle) to 1 (line)
           eps is a 'bunching' parameter that, as made larger,
               tends to bunch points near emax.  
               As a rule, e2=0 is good, or maybe e2=.5 
                to emphasize points near Ef.

 After the integration is completed, there will be some deviation from charge neutrality, because emax will not exactly correspond to the Fermi level. This deviation is ignored if **METAL=0**; otherwise, the mesh is rigidly shifted by a constant amount, and the diagonal GF interpolated using a Pade approximant to the shifted mesh. The shifting+interpolation is iterated until charge neutrality is found, as described in section 2. If the rigid shift exceeds a specified tolerance, the Pade interpolation may be suspect. Thus, the entire cycle is repeated from scratch, on the shifted mesh where the shift is estimated by Pade. 

**mode=310**: a Gaussian quadrature on an ellipse to a trial emax, as in mode 2. However, the search for the Fermi level is not done by Pade approximant, as in mode 10. Instead, a second integration proceeds along a uniform mesh from emax to some (Fermi) energy which satisfies charge neutrality. This procedure is not iterative.

    EMESH= nz 310 emin emax e1 e2 delz

           e1 and e2 are just as in mode 10
           delz      is the spacing between energy points for the 
                     second integration on the uniform mesh.



**mode=2**: is the same contour as mode=0. However, it is designed for cases when you want to resolve the energy dependence of some quantity, such as the DOS or magnetic exchange coupling. These are discussed in the GF category below. 

**mode=110**: is a contour input specific to nonequilibrium Green's function. The nonequilibrium Green's function requires additional information for the energy window between the left and right leads. (The nonequilibrium Green's function is implemented for the layer geometry in lmpg.) Thus the integration proceeds in two parts: first an integration on an elliptical path is taken to the left Fermi level (as in **mode=10**). Then an integration over is performed on the nonequilibrium contour, i.e. the energy window from the left to the right Fermi level. This integration is performed on a uniform mesh close to the real axis, as in **mode=0**. For the nonequilibrium contour, three additional pieces of information must be supplied:

      nzne  number of (uniformly spaced energy points on the nonequilibrium contour
      vne   difference in fermi energies of right and left leads, ef(R)-ef(L)
      delne Im-z on the nonequilibrium contour

The mesh is specified as

    EMESH= nz 110 emin ef(L) ecc eps nzne vne delne [del00]

The last argument plays the role of delne specifically for computing the self-energy that determines the end boundary conditions. There is an incompatibility in the requirements for Im-z in the central and end regions. the same incompatibility applies to transport and is discussed [below].

##### _Modifications of energy contour for layer geometry_
_____________________________________________________________

When computing transmission coefficients via the Landauer-Buttiker formalism, one chooses a contour as in **mode=0**. However, a there is a problem in how to choose $${\rm Im}\ z$$. A small Im-z is needed for a reliable calculation of the transmission coefficient, but using a small Im-z to determine the surface Green's function may not succeed because the GF can become long range and the iterative cycle used to generate it may not be stable. To accomodate these conflicting requirements, a surface-specific Im-z should be used, called **del00**. The **mode=0** mesh is specified as

    EMESH= nz 0 emin emax delta xx xx xx xx del00

delta is $${\bf Im} z$$ for the central region; **del00** is _Im z_ for the surfaces.

Entries xx have no meaning but are put there for compatibility with the contour used in nonequilibrium calculations. (A similar situation applies to the nonequilibrium part of the contour).

The mesh for self-consistent nonequilibrium calculations is

    EMESH= nz 110 emin ef(L) ecc eps nzne vne delne del00

