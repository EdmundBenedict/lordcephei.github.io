---
layout: page-fullwidth
title: "Annotated standard output, program lmfa"
subheadline: ""
show_meta: false
teaser: ""
permalink: "/docs/outputs/lmfa_output/"
header: no
---

_____________________________________________________________

### _Purpose_
{:.no_toc}

This page details the output generated by the free atomic code **lmfa**{: style="color: blue"}.

_____________________________________________________________

### _Table of Contents_
{:.no_toc}
*  Auto generated table of contents
{:toc}

The output documented here is mostly taken from the **lmf**{: style="color: blue"}
[tutorial for PbTe](/tutorial/lmf/lmf_pbte_tutorial/).
Some portions are adapted from other calculations, as will be indicated.

The standard output is organised by blocks.  Each section below
explains a block approximately in the order they are made.

Some parts are similar to the [**lmf**{: style="color: blue"} output](/docs/outputs/lmf_output/); in places where they are similar a cursory
treatment is given here; the reader is referred to that page.

#### Preprocessor's transformation of the input file
{::comment}
/docs/outputs/lmfa_output/#preprocessors-transformation-of-the-input-file
{:/comment}

The input file is run through the [preprocessor](/docs/input/preprocessor/), which modifies the ctrl file before it it is parsed for tags.
Normally it does this silently.  If you want to see the effects of the preprocessor use `lmf --showp ...`

_Note:_{: style="color: red"} the result is nearly identical to [**lmf**{: style="color: blue"} output](/docs/outputs/lmf_output/#preprocessors-transformation-of-the-input-file/), which see.

#### How lmf and lmfa read input differently
{::comment}
/docs/outputs/lmfa_output/#how-lmf-and-lmfa-read-input-differently
{:/comment}

To see what tags **lmfa**{: style="color: blue"} will look for, use `lmfa --input`.
[This web page](/docs/input/inputfile/#help-with-finding-tokens) explains what `--input` gives you.

The result is simlar to [**lmf**{: style="color: blue"} output](/docs/outputs/lmf_output/#display-tags-parsed-in-the-input-file).  However
**lmfa**{: style="color: blue"} parses fewer tags than **lmf**{: style="color: blue"} does; moreoever, some tags they both parse have
different meaning in the two codes.

{::comment}
<button type="button" class="button tiny radius">Click here to see differences in .</button>
{:/comment}
<div onclick="elm = document.getElementById('tags'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
Click here to see how lmf and and lmfa parse the input file differently.</div>{::nomarkdown}<div style="display:none;padding:0px;" id="tags">{:/}

Add `--input` to the **lmfa**{: style="color: blue"} and **lmfa**{: style="color: blue"} commands

~~~
$ lmfa ctrl.pbte --input > out.lmfa
$ lmf  ctrl.pbte --input > out.lmf
~~~
The output is quite verbose so only some differences are highlighted.

This appears in the lmf output

~~~
 --- Parameters for hamiltonian ---
 gmax                   reqd*  r8       1,  1
   (alias for HAM_GMAX)
   Energy cutoff for plane-wave mesh (Ry)
 - If preceding token is not parsed, attempt to read the following:
~~~

lmfa does not read **EXPRESS_gmax** (alias for **HAM_GMAX**).
For this reason you don't need to specify it when running lmfa, 
but do need to when running lmf.  Similarly, lmfa does not read
**BZ_NKABC** (another tag lmf requires), and many other tags that are optional in lmf,
e.g. **HAM_SO**.

lmfa looks for this tag, but lmf does not:

~~~
 autobas_lmto           opt    i4       1,  1     default = 0
   (alias for HAM_AUTOBAS_LMTO)
   Controls lmfa's autogeneration of LMTO basis parameters (RSMH,EH,RSMH2,EH2)
~~~

Two others lmfa looks for but lmf does not are &nbsp;**SPEC\_ATOM\_Q**&nbsp; and &nbsp;**SPEC\_ATOM\_MMOM**.
These affect the construction of the [atomic charge density](/docs/outputs/lmfa_output/#self-consistent-density-of-atoms).

The following tag is read by both codes, but the meaning differs.  From the output of lmfa:

~~~
 autobas_mto            opt    i4       1,  1     default = 0
   (alias for HAM_AUTOBAS_MTO)
   Controls lmfa's autogeneration of LMTO basis parameters (RSMH,EH,RSMH2,EH2)
   0 do not autogenerate basis parameters
   1 or 3 1-kappa parameters with Z-dependent LMX
   2 or 4 2-kappa parameters with Z-dependent LMX
   ...
~~~

From the output of lmf:

~~~
 autobas_mto            opt    i4       1,  1     default = 0
   (alias for HAM_AUTOBAS_MTO)
   Autoset basis:  controls what part of MTO basis is read from basis file basp
   0       No parameters are read from basp
   ...
~~~


In the first case the token affects how the basis parameters are _generated_; 
in the second how the basis parameters are _read_.
The same applies to **HAM_AUTOBAS_PNU** and **HAM_AUTOBAS_LOC**;
also **HAM_AUTOBAS_PFLOAT** have different meanings.

{::nomarkdown}</div>{:/}

After transformation by the preprocessor, **lmfa**{: style="color: blue"} parses for tags and substitutes default values for tags it does not
find.  To see the value of tags **lmfa**{: style="color: blue"} parses, use `lmfa --show` or `lmfa --show=2`.  The latter causes **lmfa**{:
style="color: blue"} to stop after displaying tags, and is useful if you want to see whether **lmfa**{: style="color: blue"} is doing what
you expect.  Using `--show` is useful if you want to record the input conditions in the output (be advised that the output is verbose).

The action of `--show` is similar to what occurs in lmf; see the 
[lmf output](/docs/outputs/lmf_output/#display-tags-parsed-in-the-input-file) for further discussion.

#### Self-consistent density of atoms
{::comment}
 /docs/outputs/lmfa_output/#self-consistent-density-of-atoms
{:/comment}


#### Generating basis information for the basp file 
{::comment}
 /docs/outputs/lmfa_output/#generating-basis-information-for-the-basp-file 
{:/comment}

After parsing the ctrl file, **lmfa**{: style="color: blue"} will build some
basis set information which is written to file _basp0.pbte_{: style="color: green"}

<div onclick="elm = document.getElementById('basp'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<button type="button" class="button tiny radius">Click here for a description.</button>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="basp">{:/}
{::comment}
Click here for a description.
{:/comment}

_basp.pbte_{: style="color: green"} supplies basis information (parameters **EH** and **RSMH** defining the shape of the envelope functions,
["continuous principal quantum numbers](/docs/code/asaoverview/#augmentation-sphere-boundary-conditions-and-continuous-principal-quantum-numbers) _P_
and information about local orbitals).

~~~
 rdctrl: reading basis parameters from file basp
 ioorbp: read species Pb        RSMH,EH RSMH2,EH2 P PZ
 ioorbp: read species Te        RSMH,EH RSMH2,EH2 P
         reset nkaph from 1 to 3
~~~

You can also supply this information in the ctrl file.
If both are present **lmfa**{: style="color: blue"} decides on which to
use depending on settings in **EXPRESS_autobas** or **HAM_AUTOBAS**

To see a synopsis of tokens in **AUTOBAS**,
[invoke `lmf --input`](/docs/input/inputfile/#help-with-finding-tokens-the---input-switch)
and search for **autobas**.  Tokens in **AUTOBAS are documented [here](/docs/input/inputfile/#ham).

{::nomarkdown}</div>{:/}

#### Header information
{::comment}
/docs/outputs/lmfa_output/#header-information
{:/comment}

The header information presents a condensed synopsis of some key
settings that are used in the the calculation.

~~~
 LMF:      nbas = 2  nspec = 2  vn 7.11.i  verb 35
 special:  forces
 pot:      XC:BH
 float:    float P LDA-style
 autoread: mto basis(4), pz(1), pnu(1)
 bz:       metal(5), tetra, invit
~~~

#### Lattice information
{::comment}
/docs/outputs/lmfa_output/#lattice-information
{:/comment}

This block prints informations about the lattice vectors and settings used in Ewald summations:

~~~
                Plat                                  Qlat
   0.000000   0.500000   0.500000       -1.000000   1.000000   1.000000
   0.500000   0.000000   0.500000        1.000000  -1.000000   1.000000
   0.500000   0.500000   0.000000        1.000000   1.000000  -1.000000
   alat = 12.147006  Cell vol = 448.071898

 LATTC:  as= 2.000   tol=1.00E-08   alat=12.14701   awald= 0.261
         r1=  1.807   nkd= 87       q1=  5.403   nkg= 169
~~~

_Note:_{: style="color: red"} When long, thin cells are used, or when APW's are added to the basis set, some attention needs to be paid to the Ewald tolerance.

#### Symmetry information
{::comment}
/docs/outputs/lmfa_output/#symmetry-information
{:/comment}

The block below shows symmetry operations it finds in the
crystal, and the irreducible k mesh it obtains from the point group it is given:

~~~
 SGROUP: 1 symmetry operations from 0 generators
 SYMLAT: Bravais system is cubic with 48 symmetry operations.
 SYMCRY: crystal invariant under 48 symmetry operations for tol=1e-5
 GROUPG: the following are sufficient to generate the space group:
         i*r3(1,1,-1) r4x
         i*r3(1,1,-1) r4x
 MKSYM:  found 48 space group operations ... includes inversion
 BZMESH:  16 irreducible QP from 216 ( 6 6 6 )  shift= F F F
 TETIRR: sorting 1296 tetrahedra ... 35 inequivalent ones found
~~~

Notes: (see also "Additional Exercises" below)

+ You can specify symmetry operations manually.  This is particularly useful
  when magnetic symmetry must be considered.
+ The k mesh is specifed through the number of k divisions along each of the three reciprocal lattice vectors, tag **EXPRESS_nabc**.\\
  You can also specify whether the k-mesh should pass through the origin or straddle it
  through tag **BZ_BZJOB**.
+ The Brillouin zone integration is using Bloechl's generalized tetrahedron method.
  You can also use the Methfessel-Paxton integration scheme or a Fermi function.

#### Augmentation parameters
{::comment}
/docs/outputs/lmfa_output/#augmentation-parameters
{:/comment}

The table below contains a synopsis of key parameters associated with augmentation spheres.

~~~
 species data:  augmentation                           density
 spec       rmt   rsma lmxa kmxa      lmxl     rg   rsmv  kmxv foca   rfoca
 Pb       3.045  1.218    4    3         4  0.761  1.522    15    1   1.218
 Te       3.029  1.211    3    3         3  0.757  1.514    15    1   1.211
~~~

+ **rmt** is the augmentation radius
+ **rsma** and **kmxa** are the smoothing radius and polynomial order used to expand envelope function around other sites.
+ **lmxa** is the _l_-cutoff of the augmentation.  Because of the unique way augmentation is done in this method, **lmxa** can be much lower standard augmented wave methods require
+ **lmxl** is analogous to **lmxa**, but it controls the _l_-cutoff of the charge density.  **lmxl** defaults to **lmxa**; you can often make it smaller with minimal loss of accuracy.
+ **rg**, **rsmv**, **kmxv** are concerned with adding local gaussian pseudocharges to manage the Hartree potential.
+ **foca**, **rfoca** allow for differing treatments of the core.

#### Interstitial mesh
{::comment}
/docs/outputs/lmfa_output/#interstitial-mesh
{:/comment}

The following block is concerned with the mesh used to represent the charge density,
and to evaluate matrix elements of the (unaugmented) envelope functions
The spacing of the mesh is controlled by the _G_ cutoff (**7.8** for PbTe).

~~~
 MSHSIZ: mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
         generated from gmax = 7.8 a.u. : 3647 vectors of 5832 (62%)

 GVLIST: gmax = 7.8 a.u. created 3647 vectors of 5832 (62%)
         mesh has 18 x 18 x 18 divisions; length 0.477, 0.477, 0.477
 SGVSYM: 126 symmetry stars found for 3647 reciprocal lattice vectors
~~~

Information about whether this mesh is sufficiently accurate is given
in the table beginning with _sugcut_{: style="color: green"} below.

#### Counting the size of the basis
{::comment}
/docs/outputs/lmfa_output/#counting-the-size-of-the-basis
{:/comment}

In the table below, the size of the basis is presented.
**lmfa**{: style="color: blue"} doesn't have downfolding capability, so the
important numbers are those in the "low" column.  Rows 1,2,3 indicate how
many orbitals are connected respectively with the first Hankel envelope (**EH**),
the second envelope (**EH2**), and local orbitals.
The total basis (and hamiltonian rank) consists of 55 orbitals.

~~~
 Makidx:  hamiltonian dimensions Low, Int, High, Negl: 55 0 32 63
 kappa   Low   Int   High  L+I  L+I+H  Neglected
   1      32     0     9    32    41       9
   2      18     0    23    18    41       9
   3       5     0     0     5     5      45
  all     55     0    32    55    87      63
 suham :  41 augmentation channels, 41 local potential channels  Maximum lmxa=4
~~~

#### Envelope function parameters and their G cutoffs
{::comment}
/docs/outputs/lmfa_output/#envelope-function-parameters-and-their-g-cutoffs
{:/comment}

In the table envelope function parameters for each species is given,
which defines their shape.   Also shown is an orbital-dependent **gmax**.

~~~
 sugcut:  make orbital-dependent reciprocal vector cutoffs for tol=1.0e-6
 spec      l    rsm    eh     gmax    last term   cutoff
  Pb       0    1.80  -0.10   4.123    2.68E-06     531
  Pb       1    2.02  -0.10   3.848    2.42E-06     411
  Pb       2*   2.03  -0.10   4.013    1.37E-06     531
  Pb       3    2.03  -0.10   4.193    1.54E-06     537
  Pb       0    1.80  -0.90   4.123    2.68E-06     531
  Pb       1    2.02  -0.90   3.848    2.42E-06     411
  Pb       2    2.03  -0.90   4.013    1.37E-06     531
  Te       0    1.63  -0.10   4.572    1.45E-06     725
  Te       1    1.71  -0.10   4.575    1.52E-06     725
  Te       2*   2.02  -0.10   4.037    1.63E-06     531
  Te       3    2.02  -0.10   4.218    1.87E-06     537
  Te       0    1.63  -0.90   4.572    1.45E-06     725
  Te       1    1.71  -0.90   4.575    1.52E-06     725
  Te       2    2.02  -0.90   4.037    1.63E-06     531
~~~

Each envelope function must be expanded in plane waves in order to assemble matrix elements of the interstitial potential
the output charge density.
Both are assembled in reciprocal space.
The number of plane waves needed for a particular orbital depends on how sharply peaked the function is,
so the cutoff is orbital-dependent to allow for faster execution.
**gmax** of any one orbital may safely be less than the global _G_ cutoff (**7.8** for PbTe);
if it can, _lmf_{: style="color: blue"} will find a **gmax** for each orbital
that meets a preset tolerance.  Otherwise it uses all the _G_ vectors available to it, and appends a '\*' to the number indicating
not enough orbitals are available to meet the specified tolerance (10<sup>&minus;6</sup> in this case).

If any of the orbitals bump up against the maximum, check the error estimate ("last term") in the Table.
If it is too high you can expect errors in the hamiltonian and you should increase **gmax**.

The tolerance defaults to 10<sup>&minus;6</sup>, but you can control it with tag **HAM_TOL**.
10<sup>&minus;5</sup> or smaller is usually safe.

At this stage the potential independent setup is complete.

#### Obtain an input density
{::comment}
/docs/outputs/lmfa_output/#obtain-an-input-density
{:/comment}

The next step is to generate the potential : for this a density must be given.  **lmfa**{: style="color: blue"} tries to read the density
from the density restart file, *rst.pbte*{: style="color: green"}.  The box below indicates that **lmfa**{: style="color: blue"} was not able
to find the file, and instead constructs a trial density by overlapping free atom densities:

~~~
 lmfp  : no rst file ... try to overlap atomic densities
 rdovfa: read and overlap free-atom densities (mesh density) ...
 rdovfa: expected Pb,      read Pb       with rmt=  3.0448  mesh   497  0.025
 rdovfa: expected Te,      read Te       with rmt=  3.0287  mesh   461  0.025
~~~

If you have


{::nomarkdown}</div>{:/}
