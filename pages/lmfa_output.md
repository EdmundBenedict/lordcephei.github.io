---
layout: page-fullwidth
title: "Annotated standard output, program lmfa"
subheadline: ""
show_meta: false
teaser: ""
permalink: "/docs/outputs/lmfa_output/"
header: no
---

_____________________________________________________________

### _Purpose_
{:.no_toc}

This page details the output generated by the free atomic code **lmfa**{: style="color: blue"}.

_____________________________________________________________

### _Table of Contents_
{:.no_toc}
*  Auto generated table of contents
{:toc}

The output documented here is mostly taken from the **lmf**{: style="color: blue"}
[tutorial for PbTe](/tutorial/lmf/lmf_pbte_tutorial/).
Some portions are adapted from other calculations, as will be indicated.

The standard output is organised by blocks.  The sections below
annotate each block approximately in the order they are made.
Some parts are similar to the [**lmf**{: style="color: blue"} output](/docs/outputs/lmf_output/); in places where they are similar a cursory
treatment is given here; the reader is referred to that page.

_Note:_{: style="color: red"} This document is annotated for an [output vebosity](/docs/commandline/general/#switches-common-to-most-or-all-programs) of 35 (medium verbosity)
Raising the verbosity causes **lmfa**{: style="color: blue"} to print additional information.
Verbosity 31 is a little terse; verbosity 41 is a little verbose.

### 1. Preprocessor's transformation of the input file
{::comment}
/docs/outputs/lmfa_output/#preprocessors-transformation-of-the-input-file
{:/comment}

The input file is run through the [preprocessor](/docs/input/preprocessor/), which modifies the ctrl file before it it is parsed for tags.
Normally it does this silently.  To see the effects of the preprocessor use `lmfa --showp ...`
The result is very similar to `lmf --showp ...`, which is documented 
[here](/docs/outputs/lmf_output/#preprocessors-transformation-of-the-input-file).

### 2. How lmf and lmfa read input
{::comment}
/docs/outputs/lmfa_output/#how-lmf-and-lmfa-read-input
{:/comment}

To see what tags **lmfa**{: style="color: blue"} will look for, use `lmfa --input`.
[This web page](/docs/input/inputfile/#help-with-finding-tokens) explains the function of `--input`.

The result is similar to [**lmf**{: style="color: blue"} produces](/docs/outputs/lmf_output/#display-tags-parsed-in-the-input-file).
However **lmfa**{: style="color: blue"} parses fewer tags; moreoever, some tags they both parse
have different meanings.

<div onclick="elm = document.getElementById('input'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here to compare input tags in lmfa to lmf.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="input">{:/}

Add `--input` to the **lmfa**{: style="color: blue"} and **lmf**{: style="color: blue"} commands

~~~
$ lmfa ctrl.pbte --input > out.lmfa
$ lmf  ctrl.pbte --input > out.lmf
~~~
The output is quite verbose so only some differences are highlighted.

This appears in the **lmf**{: style="color: blue"} output

~~~
 --- Parameters for hamiltonian ---
 gmax                   reqd*  r8       1,  1
   (alias for HAM_GMAX)
   Energy cutoff for plane-wave mesh (Ry)
 - If preceding token is not parsed, attempt to read the following:
~~~

**lmfa**{: style="color: blue"} does not read **EXPRESS_gmax** (alias for **HAM_GMAX**).
For this reason you don't need to specify it when running **lmfa**{: style="color: blue"}, 
but do need to when running **lmf**{: style="color: blue"}.  Similarly, **lmfa**{: style="color: blue"} does not read
**BZ_NKABC** (another tag **lmf**{: style="color: blue"} requires), and many other tags that are optional in **lmf**{: style="color: blue"},
e.g. **HAM_SO**.

**lmfa**{: style="color: blue"} looks for this tag, but **lmf**{: style="color: blue"} does not:

~~~
 autobas_lmto           opt    i4       1,  1     default = 0
   (alias for HAM_AUTOBAS_LMTO)
   Controls lmfa's autogeneration of LMTO basis parameters (RSMH,EH,RSMH2,EH2)
~~~

Two others **lmfa**{: style="color: blue"} looks for but **lmf**{: style="color: blue"} does not are &nbsp;**SPEC\_ATOM\_Q**&nbsp; and &nbsp;**SPEC\_ATOM\_MMOM**.
These affect the construction of the [atomic charge density](/docs/outputs/lmfa_output/#self-consistent-density-of-atoms).

The following tag is read by both codes, but the meaning differs.  From the output of **lmfa**{: style="color: blue"}:

~~~
 autobas_mto            opt    i4       1,  1     default = 0
   (alias for HAM_AUTOBAS_MTO)
   Controls lmfa's autogeneration of LMTO basis parameters (RSMH,EH,RSMH2,EH2)
   0 do not autogenerate basis parameters
   1 or 3 1-kappa parameters with Z-dependent LMX
   2 or 4 2-kappa parameters with Z-dependent LMX
   ...
~~~

From the output of **lmf**{: style="color: blue"}:

~~~
 autobas_mto            opt    i4       1,  1     default = 0
   (alias for HAM_AUTOBAS_MTO)
   Autoset basis:  controls what part of MTO basis is read from basis file basp
   0       No parameters are read from basp
   ...
~~~


In the first case the token affects how the basis parameters are _generated_; 
in the second how the basis parameters are _read_.
The same applies to **HAM_AUTOBAS_PNU** and **HAM_AUTOBAS_LOC**;
also **HAM_AUTOBAS_PFLOAT** have different meanings.

{::nomarkdown}</div>{:/}

{::nomarkdown} <a name="help-explained"></a> {:/}
{::comment}
/docs/outputs/lmfa_output/#help-explained
{:/comment}


`--help` performs a function similar to `--input` but for the command line arguments: it prints out a brief summary of arguments effective in the executable you are using.

<div onclick="elm = document.getElementById('clo'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<button type="button" class="button tiny radius">Click here to see --help explained.</button>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="clo">{:/}

Consider the output of `lmfa --help`.

First appears a list of command line options available in most Questaal codes.
They are described in more detail [here](/docs/commandline/general/).

~~~
 --h
 --help         Print this message, and quit
 --input        List categories, tokens, and data program expects, and quit
 --show         Print control file after parsing by preprocessor,
                and echo input data as read from the control file
 --showp        Same as --show, but quit after input parsed
 --iactiv       (--no-iactiv) Turn on (off) interactive mode
                This switch overrides input file setting
 --pr#1[,#2...] Set the verbosity (stack) to values #1,#2, ...
 --time=#1[,#2] Print timing info to # levels (#1=summary; #2=on-the-fly)

 -vnam=expr     Define numerical variable "nam"; set to result of 'expr'
 -cnam=strn     Define character variable "nam"; set to 'strn'

 --rpos=filnam  After reading input file, read site positions from "filnam"
 --fixlat       Adjust lattice vectors and point group ops, attempt to
                render them internally consistent
 --fixpos[:tol=#] Adjust positions slightly, rendering them
                as consistent as possible with the symmetry group
 --nosym        Suppress symmetry operations
~~~

Then follow a synopsis of **lmfa**{: style="color: blue"}-specific options:

~~~
 --noopt        Suppress optimization of s.m. Hankel basis
 --norscnst     In optimization of s.m. Hankel basis, do not constrain rsm < rmt
 --plotwf       Writes atomic radial wave functions to disk files
 --dumprho      Writes out the density for each atom to out.ext
 --basp         Turns on autofind EH,RSMH (better to use HAM_AUTOBAS)
 --getallloc    Look for local orbitals (better to use HAM_AUTOBAS)
~~~

{::nomarkdown}</div>{:/}

After transformation by the preprocessor, **lmfa**{: style="color: blue"} parses for tags and substitutes default values for tags it does not
find.  To see the value of tags **lmfa**{: style="color: blue"}, whether parsed or defaults, use `lmfa --show` or `lmfa --show=2`.  The latter causes **lmfa**{:
style="color: blue"} to stop after displaying tags, and is useful if you want to see whether **lmfa**{: style="color: blue"} is doing what
you expect.  Using `--show` is useful if you want to record the input conditions in the output (be advised that the output is verbose).

The action of `--show` is similar to what occurs with **lmf**{: style="color: blue"}; see
[see annotation of **lmf**{: style="color: blue"} output](/docs/outputs/lmf_output/#display-tags-parsed-in-the-input-file) for further discussion.

### 3. Header, lattice, and symmetry blockss

The header information presents a condensed synopsis of some key
settings that are used in the calculation.  It is similar to the
header table [produced by **lmf**{: style="color: blue"}](/docs/outputs/lmf_output/#header-information).

The next blocks print information about the lattice vectors and settings used in Ewald summations.  This is not relevant for **lmfa**{:
style="color: blue"}; but it is printed out anyway and is identical to [**lmf**{: style="color: blue"}
output](/docs/outputs/lmf_output/#lattice-information);
similarly for the following block on [symmetry and _k_ mesh](/docs/outputs/lmf_output/#symmetry-and-k-mesh).

### 4. Loop over species
{::comment}
 /docs/outputs/lmfa_output/#loop-over-species
{:/comment}

**lmfa**{: style="color: blue"} begins a loop over each species, and performs the following steps.

#### _Self-consistent density_
{::comment}
 /docs/outputs/lmfa_output/#self-consistent-density
{:/comment}

If _no_ local orbitals have been specified, **lmfa**{: style="color: blue"}'s printout for the first atom (Pb) begins with:

~~~
 Species Pb:  Z=82  Qc=78  R=3.044814  Q=0
 mesh:   rmt=3.044814  rmax=47.629088  a=0.025  nr=497  nr(rmax)=607
  Pl=  6.5     6.5     6.5     5.5     5.5
  Ql=  2.0     2.0     0.0     0.0     0.0
~~~

The first line shows the atomic number, number of core charges (core levels are assumed to be filled), augmentation radius
and net sphere charge.
The next line shows the augmentation radius and cutoff radius of the free atom and radial mesh parameters. 
All the Questaal codes use a shifted logarithmic mesh: point _i_ has a radius

$$ r_i = b[e^{a(i-1)}-1] $$

The first point is the origin and the last the augmentation radius.  Thus, in addition to the augmentation radius there is a free parameter.
It is sometimes fixed by spacing _a_ (input through [**SPEC_ATOM_A**](/docs/input/inputfile/#spec)); 
alternatively it can be fixed by the total number of mesh points (input through [**SPEC_ATOM_NR**](/docs/input/inputfile/#spec)).

The free atom calculation doesn't need to know about the augmentation radius, but it is needed for _atm.pbte_{: style="color: green"},
where the the augmentation and interstitial parts are kept separate.

Next follows printouts for **Pl** and **Ql**.  The **Pl** are the
[continuous principal quantum numbers](/docs/code/asaoverview/#boundary-conditions-and-continuous-principal-quantum-numbers) 
for _s_,&thinsp;_p_,&thinsp;_d_,&thinsp;&hellip; (the fractional
part is not relevant since for free atoms there is a boundary condition that the wave function decay exponentially as
<i>r</i>&rarr;&infin;).  The integer parts of **Pl** because they define what states are valence.  All states with smaller P.Q.N., e.g.
the 5_s_, are treated as core.  The **Ql** are corresponding charges.

**Pl** and **Ql** are specified by &nbsp;[**SPEC\_ATOM\_P**](/docs/input/inputfile/#spec-cat) and &nbsp;[**SPEC\_ATOM\_Q**](/docs/input/inputfile/#spec-cat).
Neither **Pl** nor **Ql** are required inputs: **lmfa**{: style="color: blue"} will use default values from a lookup table for whatever is missing.

As described in [the tutorial](/tutorial/lmf/lmf_pbte_tutorial/#local-orbitals ), **lmfa**{: style="color: blue"} finds the Pb 5_d_ to be a local orbital.
When the 5_d_ local orbital specified (by **PZ= 0 0 15.934**) in _basp.pbte_{: style="color: green"},
**lmfa**{: style="color: blue"} will include the 5_d_ in the valence.  The printout then reads:

~~~
 Species Pb:  Z=82  Qc=68  R=3.044814  Q=0
 mesh:   rmt=3.044814  rmax=47.629088  a=0.025  nr=497  nr(rmax)=607
  Pl=  6.5     6.5     5.5     5.5     5.5    
  Ql=  2.0     2.0     10.0    0.0     0.0    
~~~

**Qc** is smaller by 10 and the 5_d_ are included in the valence with 10 electrons (**Pl** is reduced to **5.5** and **Ql** becomes **10**).

The **Ql** and the boundary condition at <i>r</i>&rarr;&infin; are sufficient to completely determine the charge density.  The total
self-consistent charge density should be the same in either case, but the valence-core partitioning is different.

**lmfa**{: style="color: blue"} starts with a crude guessed density and after 55 iterations converges to the self-consistent one.

~~~
  iter     qint         drho          vh0          rho0          vsum     beta
    1   82.000000   2.667E+04      410.0000    0.4078E+03     -164.7879   0.30
   55   82.000000   4.614E-05     1283.9616    0.3612E+08     -309.4131   0.30
~~~

#### _Valence and core wave functions_
{::comment}
 /docs/outputs/lmfa_output/#valence-wave-and-core-functions
{:/comment}

In this block information about the eigenvalues of the valence and core states it finds along with some additional information, such as
what fraction of the state falls outside the augmentation radius.

<div onclick="elm = document.getElementById('wavefunctions'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for annotation of wave function printout.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;" id="wavefunctions">{:/}

The following is taken from standard output:

~~~
 valence:      eval       node at      max at       c.t.p.   rho(r>rmt)
   6s      -0.91143         1.014       1.961       2.814     0.168779
   6p      -0.27876         1.185       2.643       4.790     0.524423
   5d      -1.56879         0.523       1.073       2.252     0.007786
...

 core:        ecore       node at      max at       c.t.p.   rho(r>rmt)
   1s   -6465.77343         0.000       0.010       0.022     0.000000
   2s   -1155.91509         0.020       0.057       0.090     0.000000
...
   5p      -6.31315         0.486       0.882       1.314     0.000052
~~~

+ **eval** is the eigenvalue
+ **node at** is the largest radius for which the wave function has a node
+ **max at**  is the radius where the wave function has a maximum value
+ **c.t.p**   is the classical turning point
+ rho(r&gt;rmt) is the charge spilling outside the augmentation radius.  For Pb 5_d_, **0.007786** electrons spill out: this is on the
  ragged edge of whether it needs to be included as a local orbital (see Additional Exercises in the
  [tutorial](/tutorial/lmf/lmf_pbte_tutorial/#additional-exercises)).

_Note:_{: style="color: red"} for _GW_ calculations the Pb 5_d_ state is too shallow to be treated as a core.

{::nomarkdown}</div>{:/}

#### _Generating basis information_
{::comment}
/docs/outputs/lmfa_output/#generating-basis-information
{:/comment}

From the self-consistent density and potential, **lmfa**{: style="color: blue"} will build some
basis set information which is written to template _basp0.pbte_{: style="color: green"}.  It supplies

+ envelope function (parameters **EH** and **RSMH** defining the shape of the envelope functions)
+ ["continuous principal quantum numbers](/docs/code/asaoverview/#augmentation-sphere-boundary-conditions-and-continuous-principal-quantum-numbers) _P_
+ information about local orbitals

These bits of information are written to file _basp0.pbte_{: style="color: green"}.

<div onclick="elm = document.getElementById('envelope'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for annotation of lmfa's generation of envelope function parameters and boundary condition at the augmentation radius.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;"id="envelope">{:/}

Fitting **RSMH** and **EH** to the numerically derived wave functions
can be readily accomplished.  **lmfa**{: style="color: blue"} does it
in two steps.  First it does the estimate for the occupied levels only
and at the same time computes a variational estimate for the energy.
In peturbation theory this differs from the exact value computed from
numerical wave functions as the difference in in single-particle sum.

The information is displayed in the following table for each _l_ that
carries electrons.  **rmt** is the augmentation radius.

~~~
 Optimise free-atom basis for species Pb, rmt=3.044814
 l  it    Rsm      Eh     stiffR   stiffE      Eval      Exact     Pnu    Ql
 0  50   1.794  -0.698      88.6    108.3   -0.91141  -0.91143    6.89   2.00
 1  26   2.026  -0.161     182.6    936.8   -0.27824  -0.27876    6.81   2.00
 eigenvalue sum:  exact  -2.38037    opt basis  -2.37931    error 0.00106
~~~

+ **Rsm** and **Eh* are the optimum **RSMH** and **EH** for the atom
+ **StiffR and stiffE** are the sensitivity of the total energy to 
  changes in **Rsm** and **Eh*
+ **Eval**    is the expectation value of the numerical wave function for _r_&;lt;**rmt**
  and the fit function for _r_&;gt;**rmt**, from the variational principle.
+ **Exact**   is the exact eigenvalue of the self-consistent potential.
+ **Pnu** is the logarithmic derivative of the exact atomic wave function at **rmt**,
  converted into the "continuous principal quantum number".

_Notes:_{: style="color: red"} 

+ The variational **Eval** should be less binding than the **Exact** value
+ The error in the total energy, using the envelope functions, is given in the last line.
+ The fit is evidently very good.  Unfortunately, it is less good in the crystal because crystal eigenfunctions consist of tails from
  envelopes centered elsewhere as well this atom.  So even at **rmt**, and even if the potential were the same as atomic potential there (in
  reality is is slightly different) the crystal eigenfunction will not be perfect.  The new [Jigsaw Puzzle Orbital](/docs/code/jpos) basis
  is designed to deal exactly with these issues.


After the initial fit, a second fit is carried out, this time with all the partial waves.
Unoccupied states may not be bound, so **Eh** is set to a default value.
This information is displayed in the following table.

~~~
 Make LMTO basis parms for species Pb to lmxb=3, rmt=3.0448  vbar=0
 l  it    Rsm       Eh        Eval      Exact     Pnu    Ql   Gmax
 0  30   1.803   -0.706    -0.91141  -0.91143    6.89   2.00   3.9
 1  18   2.024   -0.160    -0.27825  -0.27876    6.81   2.00   3.6
 2   1   2.030+  -0.100+   -0.11512   0.01352    6.24   0.00
 3   1   2.030+  -0.100+    0.20219   0.02051    5.18   0.00

 Autogenerated Pnu:  6.895 6.809 6.250 5.183 5.089
~~~

**Rsm**, **Eh*, and **Pnu** are saved in _basp0.pbte_{: style="color: green"}.

{::nomarkdown}</div>{:/}


<div onclick="elm = document.getElementById('lo'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for annotation of lmfa's treatment of local orbitals.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;"id="lo">{:/}

~~~
 Find local orbitals which satisfy E > -2 Ry  or  q(r>rmt) > 5e-3
 l=2  eval=-1.569  Q(r>rmt)=0.0078  PZ=5.934  Use: PZ=15.934
 l=3  eval=-9.796  Q(r>rmt)=3e-8  PZ=4.971  Use: PZ=0.000
~~~

{::nomarkdown}</div>{:/}

#### _Fitting the charge density outside the augmentation radius_
{::comment}
 /docs/outputs/lmfa_output/#fitting-the-charge-density-outside-the-augmentation-radius
{:/comment}

**lmfa**{: style="color: blue"} retains two densities on the numerical mesh for points
inside the augmentation sphere: the core and valence densities.

In addition it must keep some information about the density outside.  This density will become part of the interstitial density in the
crystal.  Thus it must be represented on the interstitial charge density mesh and one-center expansions of it made to include the
contribution to neighboring sites from this atom's density.

Both can be readily accomplished if the density is represented as a linear combination of [smooth Hankel functions](/docs/code/smhankels).
**lmfa**{: style="color: blue"} fits the numerical density to a linear combination of such functions; the smoothing radii, energies, and fit
coefficients are stored in _atm.pbte_{: style="color: green"}.  The fit is done subject to the constraint that the integrated charge is exact.

<div onclick="elm = document.getElementById('valfit'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for annotation of lmfa's printout of the valence density fitting.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;"id="valfit">{:/}

~~~
 tailsm: fit tails to 6 smoothed hankels, rmt= 3.02869, rsm= 1.51434
 HNSMFT:  85 points in interval  3.02869  24.73301;  q=  1.433395
 E:    -1.00000    -2.00000    -4.00000    -6.00000    -9.00000    -15.0000
 C:    -0.10708    13.99477    -208.816    3199.570    -32652.0    736827.1
        r          rho         fit         diff
    3.028689    0.013779    0.013777    0.000002
    3.888922    0.003349    0.003348    0.000000
    4.993484    0.000541    0.000541    0.000000
    6.411769    0.000054    0.000054    0.000000
    8.232883    0.000003    0.000003    0.000000
    q(fit):     1.433395    rms diff:   0.000002
    fit: r>rmt  1.433395   r<rmt  6.387103   qtot  7.820498
    rho: r>rmt  1.433395   r<rmt  4.566605   qtot  6.000000
~~~
{::nomarkdown}</div>{:/}

Also the core density spills out into the interstitial.  Rather than renormalizing the core density
inside the augmentation sphere, it is allowed spill out and included in the interstitial density.
**lmfa**{: style="color: blue"} fits the core tail to a single smoothed Hankel function.

<div onclick="elm = document.getElementById('corefit'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';">
<span style="text-decoration:underline;">Click here for annotation of lmfa's printout of the core density fitting.</span>
</div>{::nomarkdown}<div style="display:none;padding:0px;"id="corefit">{:/}

~~~
 coretail: q=0.00215, rho(rmt)=0.00566.  Fit with Hankel e=-14.401  coeff=639.|
      r            rhoc          fit
    3.028689    0.01975240    0.01975240
    3.347222    0.00650048    0.00651738
    3.792904    0.00136878    0.00136091
    4.297927    0.00023338    0.00022687
    4.870194    0.00003132    0.00002930
    5.518656    0.00000320    0.00000283
    6.253461    0.00000024    0.00000020
    7.086104    0.00000001    0.00000001
~~~
{::nomarkdown}</div>{:/}

### 5. Estimating the plane-wave cutoff GMAX
{::comment}
 /docs/outputs/lmfa_output/#estimating-the-plane-wave-cutoff-gmax
{:/comment}

~~~
 FREEAT:  estimate HAM_GMAX from RSMH:  GMAX=4.3 (valence)  7.8 (local orbitals)
~~~

