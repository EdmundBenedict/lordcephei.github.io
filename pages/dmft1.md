---
layout: page-fullwidth
title: "First tutorial on QSGW+DMFT"
permalink: "/tutorial/qsgw_dmft/dmft1/"
sidebar: "left"
header: no
---

# Setting up a QSGW+DMFT calculation

This tutorial assumes you have terminated a QSGW calculation and you want to start a DMFT calculation. Your QSGW calculation is supposed to be spin-polarized (even for non-magnetic materials). For the purpose of this tutorial, we will refer to a QSGW calculation on ferromagnetic Nickel. 

If you want to start from scratch, you can follow the instructions below to prepare the magnetic QSGW calculation (but they are very concise and must be followed with reference to the QSGW tutorial). Otherwise you can download the result of the converged QSGW loop from [this link](https://lordcephei.github.io/assets/download/inputfiles/dmft1.tar.gz).

<div onclick="elm = document.getElementById('qsgw_ni'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Commands to run QSGW on Ni from scratch - Click to show.</button></div>
{::nomarkdown}<div style="display:none;margin:0px 25px 0px 25px;"id="qsgw_ni">{:/}

The file *init.ni*{: style="color: green"} to start working on Ni is: 

```
LATTICE
   SPCGRP=225
   A=3.524 UNITS=A
SITE
   ATOM=Ni X=0 0 0
   MMOM=0.0 0.0 0.6
```

To run a full QSGW calculation follow the commands below

```
blm ni --gw --wsitex
mv actrl.ni ctrl.ni
vi ctrl.ni       # edit control file assigning nit=20, sig=8, nkabc=10, gmax=8.7 among the % const section
lmfa ni -vnsp=2
mv basp0.ni basp.ni
lmf ni -vnsp=2   # At the end of this run (10 iterations, few minutes) mmom=.6442223 ; ehf=-3036.6239355
echo '-1' | lmfgwd ni -vnsp=2
lmgwsc --wt --openmp=20 --code2 --sym -maxit=15 --metal --getsigp --tol=2e-5  -vnsp=2 ni
```
The value of the parameters chose are a pretty low but they can provide a fast enough starting point for the QSGW+DMFT loop. 
The total time required by the calculation above is ~10 hours.

{::nomarkdown}</div>{:/}

### Prepare input folders and files 

Relevant files are dispatched into two folders.

```
mkdir lmfinput qmcinput                                # prepare input folders
cp *.lsco lmfinput                                     # copy input files relevant for lmfdmft
cp atom_d.py broad_sig.f90 Trans.dat PARAMS qmcinput/  # copy files and programs relevant for CTQMC
```

##### Prepare the *ctrl*{: style="color: green"} file

After copying the relevant files in the input folders, you need to compile *broad_sig.f90*{: style="color: green"} and add a string of tokens to *ctrl.lsco*{: style="color: green"}. 

```
cd lmfinput
echo 'DMFT    PROJ=2 NLOHI=11,53 BETA=50 NOMEGA=1999 KNORM=0' >> ctrl.lsco  # add a line to the ctrl file 
cd ..
```

The token **DMFT_NLOHI** defines the projection window in band index, **DMFT_BETA** is the inverse temperature in eV$$^{-1}$$ and **DMFT_NOMEGA** is the number of Matsubara frequencies in the mesh. Some detail of the projection procedure are controlled by **DMFT_PROJ** and **DMFT_KNORM**, but you are not meant to change their value.
Moreover we suggest you to add **% const bxc0=0** and **BXC0={bxc0}** in the **HAM** section of the *ctrl*{: style="color: green"} file.

You can see how it should look like by clicking on the dropdown box.
<div onclick="elm = document.getElementById('ctrl-4dmft'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Example of ctrl.file for La2CuO4- Click to show.</button></div>
{::nomarkdown}<div style="display:none;margin:0px 25px 0px 25px;"id="ctrl-4dmft">{:/}

```

  # Autogenerated from init.lsco
  VERS    LM:7 FP:7
  IO      SHOW=f HELP=f WKP=F IACTIV=f VERBOS=31
  % const pwmode=0 pwemax=3 # Use pwmode=1 or 11 to add APWs
  HAM     AUTOBAS[PNU=1 LOC=1 LMTO=5 MTO=4 GW=1]  GMAX=9.2
          PWMODE={pwmode} PWEMIN=0 PWEMAX={pwemax} OVEPS=0
  % const bxc0=0
          BXC0={bxc0}
  % const nsp=1 so=0 elind=-.7
          NSPIN={nsp} SO={so} FORCES={so==0} ELIND={elind}
  % const lxcf=2 lxcf2=-1 # for PBE functional use lxcf=101 lxcf2=130
  % ifdef lxcf & lxcf2>0
          XCFUN=0,{lxcf},{lxcf2}     # format for libxc functionals
  % else
          XCFUN={lxcf}               # internally compiled functionals
  % endif
  % const sig=12 sigint=4 gwemax=2
          RDSIG={sig} SIGP[MODE={sigint} EMAX={gwemax}]
  % const nit=1
  ITER    MIX=B2,b=.3,k=10  NIT={nit}  CONVC=1e-5
  % const met=5 nk=0
  BZ      NKABC={nk}  METAL={met}  # NKABC requires 1 to 3 positive numbers
  #SYMGRP i r4z mx
  % const a=7.155637
  EWALD   TOL=1e-10
  STRUC
    NSPEC=3  NBAS=7  NL=5
    ALAT={a}
    PLAT= -0.5  0.5  1.7334812  0.5  -0.5  1.7334812  0.5  0.5  -1.7334812
  % const gcutb=2.0 gcutx=1.7 nkgw=0
  GW      NKABC={nkgw} GCUTB={gcutb} GCUTX={gcutx}
          DELRE=.01 .5 MKSIG=3 GSMEAR=0.003 PBTOL=1e-3
  SPEC
    ATOM=La         Z= 57  R= 2.769375  LMX=3  LMXA=4
    ATOM=Cu         Z= 29  R= 1.905511  LMX=3  LMXA=4
    ATOM=O          Z=  8  R= 1.672308  LMX=3  LMXA=4
  SITE
    ATOM=La         POS=  0.5000000   0.5000000  -0.4807290
    ATOM=La         POS= -0.5000000  -0.5000000   0.4807290
    ATOM=Cu         POS=  0.0000000   0.0000000   0.0000000
    ATOM=O          POS=  0.0000000   0.5000000   0.0000000
    ATOM=O          POS=  0.0000000   0.0000000   0.6320273
    ATOM=O          POS= -0.5000000   0.0000000   0.0000000
    ATOM=O          POS=  0.0000000   0.0000000  -0.6320273
  DMFT    PROJ=2 NLOHI=11,53 BETA=50.0 NOMEGA=1999 KNORM=0
```
{::nomarkdown}</div>{:/}

##### Compile **broad_sig.f90**{: style="color: blue"}
The statistical noise of Quantum Monte Carlo calculations can be sourse of instabilities. Because of this, you need to broad the output of the **ctqmc**{: style="color: blue"} software.
The **Questaal**{: style="color: blue"} package prvides **broad_sig.f90**{: style="color: blue"}, but you can use whatever method you prefer. 

```
cd qmcinput
gfortran -o broad_sig.x broad_sig.f90                  # compile (here with gfortran) the broadening program
cd ..
```
The tutorial will continue assuming you are using **broad_sig.f90**{: style="color: blue"}.

##### Prepare spin-averaged self-energy
The starting point of the DMFT loop has to be non-magnetic, but the QSGW (or LDA) calculation you just finishes can be magnetic. 

If this is the case you need to spin average the QSGW self-energy and construct the LDA $$V_{\rm xc}$$ by reading only the spin-averaged density.

```
lmf --rsig~spinav --wsig -vbxc0=1 > log
```

You will see that the file *sigm2.lsco*{: style="color: green"} has been created. 

### Prepare a vanishing impurity self-energy 
Unless you want to rely on some previous calculation, you start the loop from scratch by creating an empty impurity self-energy. 

```
mkdir siginp0
cd siginp0
cp ../lmfinput/*  . 
lmfdmft lsco -vnk=4 -rs=1,0 --ldadc=82.2 -job=1  > log
```

You can check that a file called *sig.inp*{: style="color: green"} has been created. It is formatted with the first column being the Matsubara frequencies (in eV) and then a number of columns equal to twice the number of _m_ channels (e.g. ten columns for d-type impurity: five pairs of real and imaginary parts).
