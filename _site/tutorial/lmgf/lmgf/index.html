<!doctype html> <html class="no-js" lang="en"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>lmgf tutorial</title> <link rel="stylesheet" href="https://lordcephei.github.io/assets/css/styles_feeling_responsive.css"> <script src="https://lordcephei.github.io/assets/js/modernizr.min.js"></script> <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script> <script> WebFont.load({ google: { families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ] } }); </script> <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script> <noscript> <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic|Volkhov' rel='stylesheet' type='text/css'> </noscript> <meta name="google-site-verification" content="KBbEPlf44q4dfL6SBHqymelMqXBSuZHSXIo-ZfkQLbE" /> <meta name="msvalidate.01" content="0FB4C028ABCF07C908C54386ABD2D97F" /> <meta name="description" content=""/> <link rel="author" href="https://plus.google.com/u/0/104386739373934968982"/> <link rel="icon" sizes="32x32" href="https://lordcephei.github.io/assets/img/favicon-32x32.png"> <link rel="icon" sizes="192x192" href="https://lordcephei.github.io/assets/img/touch-icon-192x192.png"> <link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://lordcephei.github.io/assets/img/apple-touch-icon-180x180-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://lordcephei.github.io/assets/img/apple-touch-icon-152x152-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://lordcephei.github.io/assets/img/apple-touch-icon-144x144-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://lordcephei.github.io/assets/img/apple-touch-icon-120x120-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://lordcephei.github.io/assets/img/apple-touch-icon-114x114-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://lordcephei.github.io/assets/img/apple-touch-icon-76x76-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://lordcephei.github.io/assets/img/apple-touch-icon-72x72-precomposed.png"> <link rel="apple-touch-icon-precomposed" href="https://lordcephei.github.io/assets/img/apple-touch-icon-precomposed.png"> <meta name="msapplication-TileImage" content="https://lordcephei.github.io/assets/img/msapplication_tileimage.png"/> <meta name="msapplication-TileColor" content="#fabb00"> <!-- Facebook Optimization --> <meta property="og:locale" content="en_EN" /> <meta property="og:type" content="website" /> <meta property="og:title" content="lmgf tutorial" /> <meta property="og:description" content="Questaal is a suite of programs for LMTO and GW simulations."/> <meta property="og:url" content="https://lordcephei.github.io//tutorial/lmgf/lmgf/" /> <meta property="og:site_name" content="Questaal" /> <!-- Search Engine Optimization --> <link type="text/plain" rel="author" href="https://lordcephei.github.io/humans.txt" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "AMSmath.js"], jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [ ['$','$'] ], displayMath: [ ['$$','$$'] ], processEscapes: true }, }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script> <style type="text/css"> red { color:purple; /*This changes the color of your text */ font-size:24pt; /*This changes the font size of your text */ } </style> </head> <body id="top-of-page" class="page-fullwidth"> <div id="navigation" class="sticky"> <nav class="top-bar" data-topbar> <ul class="title-area"> <li class="name"> <h1 class="hide-for-large-up"> <a href="https://lordcephei.github.io"> <img src="https://lordcephei.github.io/images/logo.png" style="width:125px;height:40px"></a></h1> </li> <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone --> <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li> </ul> <section class="top-bar-section"> <ul class="left"> <li class ="show-for-large-up"><a href="https://lordcephei.github.io/"> <img src="https://lordcephei.github.io/images/logo.png" style="width:125px;height:40px"></a></li> <li class="divider"></li> <li class="has-dropdown"> <a href="https://lordcephei.github.io">Functionality</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/functionality/application/">By Physical Application</a></li> <li><a href="https://lordcephei.github.io/functionality/program/">By Suite Program</a></li> </ul> </li> <li class="divider"></li> <li class="has-dropdown"> <a href="https://lordcephei.github.io">Documentation</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/package_overview/">Package Overview</a></li> <li><a href="https://lordcephei.github.io/docs/install/">Installation</a></li> <li class="has-dropdown"><a href="#">Description by code</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/code/fpoverview/">Full Potential Overview</a></li> <li><a href="https://lordcephei.github.io/docs/code/gwoverview/">GW Overview</a></li> <li><a href="https://lordcephei.github.io/docs/code/dmftoverview/">Dynamical Mean Field Theory</a></li> <li><a href="https://lordcephei.github.io/docs/code/asaoverview/">ASA Overview</a></li> <li><a href="https://lordcephei.github.io/docs/code/lmgf/">ASA Green's function</a></li> <li><a href="https://lordcephei.github.io/docs/code/smhankels/">Smooth Hankel Functions</a></li> <li><a href="https://lordcephei.github.io/docs/code/jpos/">Jigsaw Puzzle Orbitals</a></li> <li><a href="https://lordcephei.github.io/docs/code/cpadoc/">CPA Enhancement of the Green's function package</a></li> <li><a href="https://lordcephei.github.io/docs/code/spectral-functions/">Spectral function calculations with lmgf</a></li> </ul></li> <li class="has-dropdown"><a href="#">Input Files</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/input/inputfile/">The Input File</a></li> <li><a href="https://lordcephei.github.io/docs/input/preprocessor/">File Preprocessor</a></li> <li><a href="https://lordcephei.github.io/docs/input/sitefile/">The Site file</a></li> <li><a href="https://lordcephei.github.io/docs/input/symfile/">Symmetry Line Files</a></li> </ul></li> <li class="has-dropdown"><a href="#">Annotated Output Files</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/outputs/lmf_output/">lmf standard output</a></li> </ul></li> <li class="has-dropdown"><a href="#">Command Line Options</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/commandline/general/">General</a></li> <li><a href="https://lordcephei.github.io/docs/commandline/lmf/">lmf</a></li> <li><a href="https://lordcephei.github.io/docs/commandline/lm/">lm</a></li> </ul></li> <li class="has-dropdown"><a href="#">Physical Properties</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/properties/optics/">Optics</a></li> </ul></li> <li class="has-dropdown"><a href="#">Auxilliary tools</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/misc/plbnds/">The plbnds tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/pldos/">The pldos tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/fplot/">The fplot tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/mccalcdoc/">The mc calculator</a></li> <li><a href="https://lordcephei.github.io/docs/misc/pfitdoc/">The pfit tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/ccomp/">The ccomp processor</a></li> <li><a href="https://lordcephei.github.io/docs/misc/integerlists/">Integer list syntax</a></li> <li><a href="https://lordcephei.github.io/docs/misc/rotations/">Specifying rotations</a></li> </ul></li> </ul> </li> <li class="divider"></li> <li class="has-dropdown"> <a href="https://lordcephei.github.io">Tutorials</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/importing_input/">Importing Input files</a></li> <li class="has-dropdown"><a href="#">lmf</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_tutorial/">Basic Tutorial for Full-Potential lmf</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_pbte_tutorial/">Self-consistent density in PbTe</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_bi2te3_tutorial/">Properties of the lmf basis set</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/fpnew/">Elastic constant in Al</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/fpoptbas/">lmf Basis Set Optimisation</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/pdos/">Generating a Partial DOS</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/mulliken/">Performing Mulliken Analysis</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/fermisurface/">Generating a Fermi Surface</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/cls/">Performing Core Level Spectroscopy</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_bandedge/">Extremal points and calculating effective mass</a></li> </ul></li> <li class="has-dropdown"><a href="#">ASA</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/asa/lm_pbte_tutorial/">LM Tutorial</a></li> </ul></li> <li class="has-dropdown"><a href="#">GW</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/gw/poscar_qsgw/">POSCAR to QSGW</a></li> <li><a href="https://lordcephei.github.io/tutorial/gw/qsgw_si/">Basic QSGW Tutorial: Si</a></li> <li><a href="https://lordcephei.github.io/tutorial/gw/qsgw_fe/">QSGW Tutorial for Fe</a></li> <li><a href="https://lordcephei.github.io/tutorial/gw/gw_self_energy/">The GW Self-energy and Spectral Function</a></li> </ul></li> <li class="has-dropdown"><a href="#">lmgf</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/lmgf/lmgf">LMGF Tutorial</a></li> </ul></li> <li class="has-dropdown"><a href="#">qsgw + dmft</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft0/">Introduction</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft1/">Setting up the DMFT loop</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft2/">Running the DMFT loop</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft3/">Issues with input and parameters</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft4/">Charge + static-magnetic contributions</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft5/">The density loop</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/maxent1/">The maximum entropy method</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft7/">The self-energy loop and the dynamical double-counting</a></li> </ul></li> <li class="has-dropdown"><a href="#">tbe</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/tbe/tbectrl">TBE Tutorial</a></li> </ul></li> <li class="has-dropdown"><a href="#">Physical Application</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/application/optics/">Optics using lm and lmf</a></li> <li><a href="https://lordcephei.github.io/tutorial/application/fstut/">Making a Fermi surface</a></li> </ul></li> <li class="has-dropdown"><a href="#">Miscellaneous</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/misc/extbfield/">Adding external Zeeman field to the potential</a></li> </ul></li> </ul> </li> <li class="divider"></li> <li class=""><a href="https://lordcephei.github.io/formatting/">Site Contribution</a></li> <li class="divider"></li> <li class=""><a href="https://lordcephei.github.io/developers/">Developers</a></li> <li class="divider"></li> </ul> <ul class="right"> <li class="divider"></li> <li><a href="https://lordcephei.github.io/search/">Search</a></li> <li class="divider"></li> <li><a href="https://lordcephei.github.io/contact/">Contact</a></li> <li class="divider"></li> <li><a href="https://lordcephei.github.io/about/">About</a></li> </ul> </section> </nav> </div><!-- /#navigation --> <div class="row t30"> <div class="medium-12 columns"> <article> <header> <p class="subheadline"></p> <h1>lmgf tutorial</h1> </header> <p class="teaser"> </p> <h3 class="no_toc" id="table-of-contents"><em>Table of Contents</em></h3> <ul id="markdown-toc"> <li><a href="#preliminaries" id="markdown-toc-preliminaries"><em>Preliminaries</em></a></li> <li><a href="#purpose" id="markdown-toc-purpose"><em>Purpose</em></a></li> <li><a href="#tutorial" id="markdown-toc-tutorial"><em>Tutorial</em></a> <ul> <li><a href="#building-input-file" id="markdown-toc-building-input-file"><em>1. Building input file</em></a> <ul> <li><a href="#the---asa-switch" id="markdown-toc-the---asa-switch"><em>The --asa switch</em></a></li> <li><a href="#the---mag-switch" id="markdown-toc-the---mag-switch"><em>The --mag switch</em></a></li> <li><a href="#the---gf-switch" id="markdown-toc-the---gf-switch"><em>The --gf switch</em></a></li> </ul> </li> <li><a href="#making-ctrl-file-and-structure-constants" id="markdown-toc-making-ctrl-file-and-structure-constants"><em>2. Making ctrl file and structure constants</em></a></li> <li><a href="#the-greens-function-program-lmgf" id="markdown-toc-the-greens-function-program-lmgf"><em>3. The Green’s function program lmgf</em></a> <ul> <li><a href="#a-finding-ef" id="markdown-toc-a-finding-ef"><em>a) Finding <script type="math/tex">E_F</script></em></a></li> <li><a href="#b-magnetic-exchange-interactions" id="markdown-toc-b-magnetic-exchange-interactions"><em>b) Magnetic Exchange Interactions</em></a></li> </ul> </li> </ul> </li> </ul> <h3 id="preliminaries"><em>Preliminaries</em></h3> <hr /> <p>For this tutorial the <strong style="color: blue">blm</strong>, <strong style="color: blue">lmchk</strong>, <strong style="color: blue">lmstr</strong>, <strong style="color: blue">lm</strong> and <strong style="color: blue">lmgf</strong> executibles are required and are assumed to be in your PATH; the source code for all Questaal exectuables can be found <a href="https://bitbucket.org/lmto/lm">here</a>.</p> <h3 id="purpose"><em>Purpose</em></h3> <hr /> <p>This package implements the ASA local spin-density approximation using Green’s functions. The Green’s functions are contructed by approximating KKR multiple-scattering theory with an analytic potential function. The approximation to KKR is essentially similar to the linear approximation employed in band methods such as LMTO and LAPW. It can be shown that this approximation is nearly equivalent to the LMTO hamiltonian without the “combined correction” term. With this package a new program, <strong style="color: blue">lmgf</strong> is added to the suite of executables. <strong style="color: blue">lmgf</strong> plays approximately the same role as the LMTO-ASA band program <strong style="color: blue">lm</strong>: a potential is generated from energy moments <script type="math/tex">Q_0</script>, <script type="math/tex">Q_1</script>, and <script type="math/tex">Q_2</script> of the density of states. in the same way as the <strong style="color: blue">lm</strong> code. You can use <strong style="color: blue">lmgf</strong> to make a self-consistent density as you can do with <strong style="color: blue">lm</strong>. lmgf is a Green’s function method: Green’s functions have less information than wave functions, so in one sense the things you can do with lmgf are more limited: you cannot make the bands directly, for example. However <strong style="color: blue">lmgf</strong> enables you do do things you cannot do with <strong style="color: blue">lm</strong>. The two most imprortant are:</p> <ul> <li>Calculate magnetic exchange interactions</li> <li>Calculate magnetic susceptibility (spin-spin, spin-orbit, orbit-orbit parts)</li> <li>Calculate properties of disordered materials, either chemically disordered or spin disorder from finite temperature, within the Coherent Potential Approximation, or CPA.</li> <li>Calculate the ASA static susceptibility at <script type="math/tex">q=0</script> to help converge calculations to self-consistency.</li> </ul> <p><strong>You can find some extra information on the way</strong> <strong style="color: blue">lmgf</strong> <strong>works in</strong> <a href="https://lordcephei.github.io/lmgf-documentation/">lmgf documentation</a>.</p> <div onclick="elm = document.getElementById('lmgfvslm'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Read about the difference between lmgf and lm</button></div> <p><div style="display:none;margin:0px 25px 0px 25px;"id="lmgfvslm"></p> <p><strong style="color: orange">lmgf vs lm</strong></p> <p><strong style="color: blue">lmgf</strong> is a Green’s function program complementary to the ASA band code <strong style="color: blue">lm</strong>. For some properties, e.g. calculating moments <script type="math/tex">Q_{0..2}</script> <strong style="color: blue">lmgf</strong> can be straightforwardly substituted for lm because both calculate the DOS. The DOS is <script type="math/tex">1/(2\pi ) {\rm Im} G</script>: it can be decomposed into site contributions and thus moments Q0..2 can be generated for each site and l channel, as an alternative to decomposing the eigenfunctions of the bands, as lm does. Thus it can achieve self-consistency in a manner similar to lm, but generating <script type="math/tex">Q_{0..2,{\bf R}l}</script> by an alternate route. If the ASA hamiltionian built by <strong style="color: blue">lm</strong> is suitably simplified, i.e. by</p> <ul> <li>omitting the “combined correction term” (<strong>OPTIONS_ASA_CCOR</strong>)</li> <li>generating <script type="math/tex">Q_{0..2,{\bf R}l}</script> from true power moments as the Green’s function does (<strong>HAM_QASA=0</strong>),</li> </ul> <p>then <strong style="color: blue">lmgf</strong> and <strong style="color: blue">lm</strong> will produce nearly identical self-consistent solutions. When potential functions are parameterized to 2nd order in both <strong style="color: blue">lm</strong> and <strong style="color: blue">lmgf</strong>, and both methods are fully k converged, they should product nearly identical results. By default lm parameterizes the potential function to 3rd order; <strong style="color: blue">lmgf</strong> can do the same. The 3rd order parameterizations are similar in the two methods, but not identical. To verify this, try the following test:</p><pre><code>gf/test/test.gf co 1 2   ← Test 1 for 2nd order parameterization; test 2 for 3rd order
</code></pre><p><strong style="color: blue">lmgf</strong> is a bit messier to work with (Green’s functions are harder to stabilize than wave functions), and it a bit less accurate as the simplifications to lm amount to approximations. So, typically lm makes a better self-consistent potential.</p> <p>But <strong style="color: blue">lmgf</strong> can do things <strong style="color: blue">lm</strong> doesn’t do, e.g. calculate magnetic exchange interactions through linear response as this tutorial demonstrates. Sometimes there is a need or advantage to carrying self-consistency via <strong style="color: blue">lmgf</strong>, e.g. when performing CPA calculations. Unless there is good reason to do otherwise, it is better use the self-consistent potential generated by <strong style="color: blue">lm</strong> to calculate other properties such as the magnetic exchange parameters. We follow that strategy here.</p> <p></div></p> <h3 id="tutorial"><em>Tutorial</em></h3> <hr /> <h5 id="building-input-file"><em>1. Building input file</em></h5> <hr /> <p>Before starting working with this tutorial we advise you to read through the <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a> which explains building the imput file in more details (you can also look through the input described in a <a href="https://lordcephei.github.io/buildingfpinput/">full-potential context</a>). In the present tutorial we’ll focus on the part of the input specific for using with <strong style="color: blue">lmgf</strong>.</p> <p>To get started, <strong>copy</strong> <strong style="color: green">doc/demos/asa-copt/init.copt</strong> to your working directory. Inspect the init file and you will see it contains just the minimum structural information, apart from one line supplying some information about the magnetic structure:</p> <div onclick="elm = document.getElementById('foobar'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Click to show the init file.</button></div> <p><div style="display:none;margin:0px 25px 0px 25px;"id="foobar"></p><pre><code>LATTICE
         ALAT=7.1866
         PLAT=    1.000000   0.000000   0.000000
                  0.000000   1.000000   0.000000
                  0.000000   0.000000   1.000000
SPEC ATOM=Co MMOM=0,0,2.2
SITE
      ATOM=Pt POS=  0.0  0.0   0.0 
      ATOM=Co POS=  0.5  0.5   0.0 
      ATOM=Co POS=  0.0  0.5   0.5
      ATOM=Co POS=  0.5  0.0   0.5 
</code></pre><p></div></p> <p>Then <strong>use the</strong> <strong style="color: blue">blm</strong> tool (described in more details in <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a> and <a href="https://lordcephei.github.io/buildingfpinput/">full-potential tutorial</a>. )</p><pre><code>blm --mag --nk=8 --asa --gf copt
</code></pre><p><strong style="color: blue">blm</strong> should generate file <strong style="color: green">actrl.copt</strong>, which should be essentially the same as <strong style="color: green">doc/demos/asa-copt/ctrl.copt</strong> (commented lines might be different though). If this is not the case, something is wrong with your configuration. <em style="color: red">At the moment if actrl looks slightly different from the one provided just move on to the next steps.</em></p> <div onclick="elm = document.getElementById('switch'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Command-line switches for CPA</button></div> <p><div style="display:none;margin:0px 25px 0px 25px;"id="switch"></p> <p>The command-line arguments are not required, but they supply quantities <strong style="color: blue">blm</strong> cannot determine automatically, that you will have to supply at some point. If you supply them on the command-line they are folded into the ctrl file at the outset; or, you can edit the ctrl file after it is generated. Command-line switches <strong style="color: blue">blm</strong> recognizes are summarized in <a href="https://lordcephei.github.io/buildingfpinput/">Building FP input file</a>.</p> <h6 id="the---asa-switch"><em>The --asa switch</em></h6> <p>This switch tailors the ctrl file for the ASA. To see how it affects the ctrl file, try running <strong style="color: blue">blm</strong> without <strong style="color: green">--asa</strong>. For more details see the <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a>.</p> <h6 id="the---mag-switch"><em>The --mag switch</em></h6> <p>This switch tells <strong style="color: blue">blm</strong> that you plan on doing a spin polarized calculation. All it does is change the preprocessor variable <em>nsp</em> to 2. This turns on the spin polarization through <strong>NSPIN={nsp}</strong>.</p> <p>Without any other information the spin polarized calculation will proceed with zero magnetic moment. The system needs a “push” in the initial direction to find the magnetic state. You have to supply some initial information about the magnetic structure. Since we know that the magnetization is concentrated on the Co (Pt is paramagnetic, though it has a high magnetic susceptibility), the init file supplies an initial magnetic moment on the Co site of about 2 Bohr on the Co d orbital, in the SPEC category (<strong>SPEC ATOM=Co MMOM=0,0,2.2</strong> in the initial file). The precise value 2.2 is not important: this quantity is determined self-consistently later. Choosing it rather large (the bulk moment is 1.8 <script type="math/tex">\mu_B</script>) gives it a strong initial push so to encourage it not revert to a (metastable) nonmagnetic state in the course of a self-consistent calculation.</p> <h6 id="the---gf-switch"><em>The --gf switch</em></h6> <p>When <strong style="color: green">--gf</strong> is used, <strong style="color: blue">blm</strong> prepares the input file for the Green’s function program <strong style="color: blue">lmgf</strong>. This tutorial uses <strong style="color: blue">lmgf</strong> to calculate magnetic exchange interactions. Adding <strong style="color: green">--gf</strong> to the <strong style="color: blue">blm</strong> command line argument modifies <strong style="color: green">actrl.copt</strong> in two ways:</p> <p><strong style="color: orange">1. The GF category is created:</strong></p><pre><code>% const gfmode=1 c3=t
GF      MODE={gfmode} GFOPTS={?~c3~p3;~p2;}
</code></pre><p>To see the purpose of <strong>GF_MODE</strong>, do:</p><pre><code>lmgf --input
</code></pre><p>and look for <strong>GF_MODE</strong>. You should see:</p><pre><code>    GF_MODE           reqd   i4       1,  1          default = 0
           0: do nothing
           1: self-consistent cycle
           10: Transverse exchange interactions J(q), MST
           11: Read J(q) from disk and print derivative properties
           ...
</code></pre><p>So, if <strong>MODE=1</strong>, <strong style="color: blue">lmgf</strong> does a self-consistent calculation, generating the <em>P</em> and <script type="math/tex">Q_{0..2}</script> for each <em>l</em> channel using Green’s functions rather than wave functions as <strong style="color: blue">lm</strong> does.</p> <p><strong>GFOPTS</strong> bundles a variety of lmgf-specific options, which you supply through a sequence of strings separated by semicolons. This tag:</p><pre><code>GFOPTS={?~c3~p3;~p2;}
</code></pre><p>becomes <strong>GFOPTS=p3</strong> after parsing by the preprocessor, because <em>c3</em> is nonzero (<strong style="color: red">see preprocessor documentation</strong>). <em>p3</em> tells <strong style="color: blue">lmgf</strong> to use <script type="math/tex">3^{rd}</script> order potential functions (somewhat more accurate than <script type="math/tex">2^{nd}</script> order, but also prone to generating false poles not too far from the real axis).</p> <p><strong style="color: orange">2. EMESH is added to BZ:</strong></p><pre><code>% const nz=16 ef=0
        EMESH={nz},10,-1,{ef},.5,.3  # nz-pts;contour mode;emin;emax;ecc;bunching
</code></pre><p>Green’s functions are energy resolved; thus physical properties such as the charge density or magnetic exchange interactions require an integration over the energy as well as over the BZ. For both density and static exchange interactions, the integration must be taken on the real axis from below the lowest eigenstate in the system to the Fermi level <script type="math/tex">E_F</script>. Im <em>G</em> is basically the density-of-states. It is very spikey on the real axis, and a very fine energy mesh would be required to integrate Im <em>G</em> close to the real axis. The integration can be accomplished with vastly greater ease by deforming the contour into an elliptical path in the complex plane. A gaussian quadrature is used; typically 15 or so energy points is sufficient for a well converged result.</p> <p>This contour is specified through <strong>EMESH</strong>. Breaking down the constituents of <strong>EMESH</strong> as autogenerated by <strong style="color: blue">blm</strong>:</p><pre><code>     EMESH={nz}          ←  number of energy points in the contour; {nz} evaluates 16 in this file
            10           ←  elliptical contour
            -1           ←  starting energy on the contour.  Must be deeper than the lowest state in the system (-0.776 Ry)
           {ef}          ←  Fermi level determined by charge neutrality; see below
           0.5           ←  eccentricity of the ellipse ranging from 0 (circle) to 1 (line)
           0.3           ←  bunching parameter, bunching points near Ef. 0→no bunching
</code></pre><p></div></p> <p>We don’t know what <script type="math/tex">E_F</script> is <em>a priori</em>. In the ASA, a general reasonable guess is 0. If we perform the band calculation, see <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a>, we get <script type="math/tex">E_F</script> generated by <strong style="color: blue">lm</strong>: it is <em>−0.12927 Ry</em>. <script type="math/tex">E_F</script> is fixed by charge neutrality. If <strong style="color: blue">lmgf</strong> generated exactly the same spectrum as <strong style="color: blue">lm</strong>, and the k-integration were fully converged (or at least identical in the two cases) <script type="math/tex">E_F</script> would be the same for <strong style="color: blue">lm</strong> as for <strong style="color: blue">lmgf</strong>. However we can expect that the charge neutrality points will slightly different in the two methods. Further we’ll find <script type="math/tex">E_F</script> using <strong style="color: blue">lmgf</strong>.</p> <p>If you want to practice finding <script type="math/tex">E_F</script> using <strong style="color: blue">lm</strong> use the following commands (for the details see <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a>) (<strong style="color: red">We advise you to do those steps since you’ll need some of them further anyway but the following lm-part contains some useful comments</strong>):</p> <div onclick="elm = document.getElementById('lm'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Click to show/hide the lm-part.</button></div> <p><div style="display:none;margin:0px 25px 0px 25px;"id="lm"></p> <p>Invoking <strong style="color: blue">blm</strong> with the switches given above is sufficient to make a working input file. Normally you can <strong>copy</strong> <strong style="color: green">actrl.copt</strong> to <strong style="color: green">ctrl.copt</strong> as it is.</p> <p>All the ASA electronic structure codes (<strong style="color: blue">lm</strong>, <strong style="color: blue">lmgf</strong>, and <strong style="color: blue">lmpg</strong>) use a tight-binding form of the LMTO basis, where the envelope functions are screened to make them short ranged. This information is carried through screened structure constants, which in this package are precomputed and stored using lmstr. Run this setup to make the structure constants:</p><pre><code> lmstr ctrl.copt                             ← Make and store structure constants
</code></pre><p>It should store <strong style="color: green">str.copt</strong> and <strong style="color: green">sdot.copt</strong> on disk. (<strong>If not, something is wrong and you should not proceed.</strong>)</p> <p>Invoking <strong style="color: blue">blm</strong> with the switches given above is sufficient to make a working input file. Normally you can <strong>copy</strong> <strong style="color: green">actrl.copt</strong> to <strong style="color: green">ctrl.copt</strong> as it is.</p> <p>As of yet we <strong>have no starting density or potential</strong>. You can see this immediately by trying to run the band code straight off:</p><pre><code>lm ctrl.copt
</code></pre><p>The program <strong>will stop</strong> with this message:</p><pre><code>LM:  Q=ATOM encountered or missing input
</code></pre><p>In usual LDA calculations, a trial density is obtained by generating densities for free atoms, and superposing them (Mattheis construction). While the ASA code could have been written to do just this, it does something different. This code takes advantage of the simplification the ASA offers, namely that the sphere density is completely determined by a small number of parameters, namely the log derivative parameters <em>P</em> and energy moments of the charge density <script type="math/tex">Q_{0..2}</script> for each <em>l</em> channel. We can supply reasonable guesses through the ctrl file, or let the program pick some defaults as a first guess. Defaults are typically assigned so that <script type="math/tex">Q_0</script> is the charge in the <em>l</em> channel of the atom and <script type="math/tex">Q_{1..2}</script> are taken to be zero. While this is a pretty crude guess (cruder than the Mattheis construction) usually it is good enough that the program can find its way to the proper self-consistent solution.</p> <p>The ASA code can either start from “potential parameters”, which gives it enough information to generate energy bands and calculate moments (<script type="math/tex">P_l</script>, <script type="math/tex">Q_{0..2,l}</script>) , or from the moments (<script type="math/tex">P_l</script>, <script type="math/tex">Q_{0..2,l}</script>)  which is sufficient for the sphere routine to fix the potential and calculated potential parameters. The band and sphere blocks of the code are thus complementary: one takes the input of the other and generates output required by the other. The cycle is described in the <strong style="color: red">LMTO-ASA documentation</strong>.</p> <p>The ctrl file is built with the following <strong>START</strong> category:</p><pre><code>START CNTROL={nit==0} BEGMOM={nit==0}
</code></pre><p>If <strong>BEGMOM</strong> is nonzero, <strong style="color: blue">lm</strong> will start from potential parameters (which don’t exist yet, in the present case). If <strong>BEGMOM=0</strong> <strong style="color: blue">lm</strong> will start from the (<script type="math/tex">P_l</script>, <script type="math/tex">Q_{0..2,l}</script>). These haven’t been given either, but <strong style="color: blue">lm</strong> can pick defaults for them. We get an initial potential by doing:</p><pre><code>lm ctrl.copt -vnit=0         ← Because -vnit=0, BEGMOM={nit} is preprocessed into BEGMOM=0
</code></pre><p><strong style="color: blue">lm</strong> will start from (default) moments and generate a trial density for each sphere, together with potential parameters corresponding to potential generated.</p> <p>The output should generate a table of potential parameters like this:</p><pre><code>PPAR:  Pt        nl=4  nsp=2  ves=  0.00000000
  l     e_nu          C        +/-del     1/sqrt(p)      gam         alp
  ...
  1 -0.33739987  0.66438324  0.17542338   6.2239779  0.13462479  0.13462479
  2 -0.21536757 -0.17914263  0.02841817   1.1299418  0.01358564  0.01358564
  ...
  1 -0.33739987  0.66438324  0.17542338   6.2239779  0.13462479  0.13462479
  2 -0.21536757 -0.17914263  0.02841817   1.1299418  0.01358564  0.01358564
  ...
</code></pre><p>and a similar table for Co. Particularly important are <em>C</em>, the band center of gravity <em>C</em> and the bandwidth <em>del</em>. You can see that <script type="math/tex">C_p</script> sits far above zero while <script type="math/tex">C_d</script> is a little below. It tells you that the Pt <em>d</em> orbital is important for bonding while the Pt <em>p</em> orbital is pretty far above from the Fermi level and of much less importance. del is the bandwidth parameter; a little more detail is given in the <strong style="color: red">LMTO-ASA documentation</strong>. A disk file is created for each class. It contains the (<script type="math/tex">P_l</script>, <script type="math/tex">Q_{0..2,l}</script>), the potential parameters, and possibly other things. Take a look at files <strong style="color: green">co.copt</strong> and <strong style="color: green">pt.copt</strong>. You can see what defaults were chosen for (<script type="math/tex">P_l</script>, <script type="math/tex">Q_{0..2,l}</script>).</p> <p>We are now ready for a self-consistent calculation. <strong>Doing</strong>:</p><pre><code>lm ctrl.copt -vnit=30 --pr31,20                ← NIT={nit} is preprocessed into NIT=30.
                                                --pr31,20 sets verbosity fairly low
</code></pre><p>will perform up to 30 self-consistent cycles, that is</p> <script type="math/tex; mode=display">PPAR\stackrel{crystal}{\longrightarrow} (P_l, Q_{0..2,l})\stackrel{sphere}{\longrightarrow} PPAR \stackrel{crystal}{\longrightarrow} (P_l, Q_{0..2,l})\stackrel{sphere}{\longrightarrow}</script> <p><strong style="color: blue">lm</strong> will continue until the RMS change in (<script type="math/tex">P_l</script>, <script type="math/tex">Q_{0..2,l}</script>) falls below tolerance <strong>ITER_CONVC</strong>, or until 30 iterations is reached.</p> <p>If it’s converged you’ll get the following phrase at the end of your output:</p><pre><code>Jolly good show! You converged to ...
</code></pre><p>In this demo convergence should be reached in 21 iterations.</p> <p><strong>Interpreting the output:</strong></p> <p>The output can provide some very useful information. For example, the self-consistent Co moment is 1.8 <script type="math/tex">\mu_B</script>; Pt has a moment (induced by the neighboring Co) of 0.3 <script type="math/tex">\mu_B</script>. You can see it in the line of the following form</p><pre><code>ATOM=PT Z=78 Qc=68 R=2.928343 Qv=-0.008929 mom=0.35606 a=0.025 nr=481
ATOM=Co ...
</code></pre><p>Scrolling up you can find the density-of-states at the Fermi level <script type="math/tex">E_F</script> is <strong>D(Ef)=72</strong> (units of <script type="math/tex">Ry^{−1}</script> per unit cell), or about 1.3 <script type="math/tex">eV^{−1}/atom</script>. Had the calculation been done without spin polarization, D(Ef) would be ~187, more than twice larger. This is a very large number and suggests there is a likely instability. Indeed, the system can lower its energy by spontaneously magnetizing. Consider the Stoner criterion for spontaneous magnetization, I D(EF) &gt; 1. In 3d transition metals I is about 1 eV. Thus the Stoner criterion is easily satisfied and the system should spontaneously magnetize. In magnetizes so strongly that the Co moment (1.8 <script type="math/tex">\mu_B</script>) is larger than that for elemental Co (1.6 <script type="math/tex">\mu_B</script>).</p> <p>The same line also provides you with the Fermi energy:</p><pre><code>BZINTS: Fermi energy:   -0.129278; ...
</code></pre><p></div></p> <h5 id="making-ctrl-file-and-structure-constants"><em>2. Making ctrl file and structure constants</em></h5> <hr /> <p><strong style="color: red">If you’ve done the lm-part above go straight to <a href="https://lordcephei.github.io/lmgf-tutorial/#the-greens-function-program-lmgf">‘The Green’s function program lmgf’</a></strong></p> <p>Invoking <strong style="color: blue">blm</strong> with the switches given above is sufficient to make a working input file. Normally you can <strong>copy</strong> <strong style="color: green">actrl.copt</strong> to <strong style="color: green">ctrl.copt</strong> as it is.</p> <p>For a fuller description of the ctrl file, see the the <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a>, the <a href="https://lordcephei.github.io/lmf_tutorial/">FP tutorial</a>, and also <a href="https://lordcephei.github.io/buildingfpinput/">Building FP input file</a>.</p> <p>All the ASA electronic structure codes (<strong style="color: blue">lm</strong>, <strong style="color: blue">lmgf</strong>, and <strong style="color: blue">lmpg</strong>) use a tight-binding form of the LMTO basis, where the envelope functions are screened to make them short ranged. This information is carried through screened structure constants, which in this package are precomputed and stored using <strong style="color: blue">lmstr</strong>. Run this setup to make the structure constants (for more detailes see see the the <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a>):</p><pre><code> lmstr ctrl.copt                             ← Make and store structure constants
</code></pre><p>It should store <strong style="color: green">str.copt</strong> and <strong style="color: green">sdot.copt</strong> on disk. (<strong>If not, something is wrong and you should not proceed.</strong>)</p> <p>As of yet we <strong>have no starting density or potential</strong>.We get an initial potential by doing:</p><pre><code>lm ctrl.copt -vnit=0        
</code></pre><p>We are now ready for a self-consistent calculation. <strong>Do</strong>:</p><pre><code>lm ctrl.copt -vnit=30 --pr31,20
</code></pre><h5 id="the-greens-function-program-lmgf"><em>3. The Green’s function program lmgf</em></h5> <hr /> <h6 id="a-finding-ef"><em>a) Finding <script type="math/tex">E_F</script></em></h6> <p>If <strong>GF_MODE=1</strong>, <strong style="color: blue">lmgf</strong> will generate the <script type="math/tex">Q_{0..2,{\bf R}l}</script> for whatever <script type="math/tex">E_F</script> you give it. However there is only one physically meaningful <script type="math/tex">E_F</script> – the one that satifies charge neutrality. The input file is constructed so you can supply <script type="math/tex">E_F</script> through command-line argument <strong style="color: green">-vef=expr</strong>: the preprocessor evaluates  ef  from  expr, substitutes it for  {ef}  in the input file (<strong style="color: red">see preprocessor documentation</strong>). We’re going to use the one obtained by running <strong style="color: blue">lm</strong> (see above).</p> <p>The simplest way to find the charge neutrality point is to run <strong style="color: blue">lmgf</strong> interactively in the self-consistent mode (<strong>GF_MODE=1</strong>). By running <strong style="color: blue">lmgf</strong> interactively you can monitor convergence. <strong>Do</strong>:</p><pre><code>lmgf ctrl.copt -vnit=30 --pr31,20 --iactiv -vef=-.1293
</code></pre><p>Since we’re using <strong>--iactiv</strong> switch the code is going to stop and ask us to make some choices. At first you’ll see</p><pre><code>QUERY: max it (def=30)?
</code></pre><p>Just hit Enter (return) to confirm. Output contains two tables the first of which looks like</p><pre><code>GFASA:  integrated quantities to efermi = -0.1293
    PL      D(Ef)      N(Ef)       E_band      2nd mom      Q-Z
spin 1   11.457550   21.527384   -7.139500    2.654650    3.027384
spin 2   79.622866   15.413290   -4.696401    1.699871   -3.086710
total   91.080415   36.940675  -11.835901    4.354521   -0.059325
       deviation from charge neutrality: -0.059325
</code></pre><p>The non-zetro deviation from charge neutrality means that ef=-.1293 results in a slight electron deficiency. <strong style="color: blue">lmgf</strong> will estimate a constant shift to crystal potential to make the system neutral, and interpolate <em>G</em> to contour adjusted by this shift using a Pade approximant.</p> <p><strong>Note</strong> <strong style="color: blue">lmgf</strong> shifts the average crystal potential: ef  is kept fixed.</p> <p>Then <strong style="color: blue">lmgf</strong> prints out some results of the Pade correction in a subsequent table.</p><pre><code>Corrections to integrated quantities estimated by Pade interpolation
    PL      D(Ef)      N(Ef)       E_band      2nd mom      Q-Z
spin 1    8.853521   21.530102   -7.151426    2.654705    3.030102
spin 2  110.784521   15.469898   -4.712034    1.700815   -3.030102
 total  119.638042   37.000000  -11.863460    4.355519   -0.000000
        deviation from charge neutrality: 0
</code></pre><p>At the prompt you should see</p><pre><code>QUERY: redo gf pass (def=F)?
</code></pre><p>It is asking you whether you want to accept the Pade approximant, or redo the GF calculation with the potential shift added. Let’s do the latter, to see how good the estimate was. At the prompt type ‘st’ and hit return twice</p><pre><code>QUERY: redo gf pass (def=F)?  st &lt;RET&gt; &lt;RET&gt;
</code></pre><p>After the cycle you should see</p><pre><code>deviation from charge neutrality: 0.015468
</code></pre><p>The Pade correction reduces the deviation from neutrality but overestimates the shift. A new estimate is made for the potential shift and the prompt reappears. You can repeat the GF cycle as many times as you like. (If you see <strong>QUERY: modify vbar (def=…)?</strong> just hit return) If you iterate enough you should see something like:</p><pre><code>gfasa:  potential shift this iter = 0.000001.  Cumulative shift = -0.000423
</code></pre><p>The shift of this last iteration is negligible.  `Cumulative shift’  is the net shift accumulated over all the iterations.</p> <p>You can now proceed to self-consistency but we will instead use the potential generated by lm in order to make the exchange parameters. (If you do proceed to self-consistency using <strong style="color: blue">lmgf</strong>, note that it writes the potential shift and Fermi level to file <strong style="color: green">vshft.copt</strong> This shift is automatically read when <strong style="color: blue">lmgf</strong> is restarted. After self-consistency is reached you can either keep <strong style="color: green">vshft.copt</strong>, or remove the file and modify  ef  so charge neutrality is satisfied without the shift.)</p> <p>At the prompt enter</p><pre><code>QUERY: redo gf pass (def=F)?  a &lt;RET&gt; 
</code></pre><p>to prevent <strong style="color: blue">lmgf</strong> from continuing its self-consistency cycle. The constant potential shift is just the negative the the requisite Fermi level shift to achieve charge neutrality:  ef needs to be adjsted to -0.1293−(-0.000423) = −0.128877 Ry.</p> <p>To confirm that this is the correct  ef, repeat the interactive <strong style="color: blue">lmgf</strong> calculation with  -vef=-0.1289.</p> <h6 id="b-magnetic-exchange-interactions"><em>b) Magnetic Exchange Interactions</em></h6> <hr /> <p>As we mentioned before <strong style="color: blue">lmgf</strong> requires a GF-specific category (look into the <strong style="color: green">ctrl.copt</strong>).</p><pre><code>GF  MODE=1 GFOPTS=options
</code></pre><p>Token <strong>MODE=</strong> controls what <strong style="color: blue">lmgf</strong> calculates. Options are MODE=1, MODE=10, MODE=11, MODE=26.</p> <p>Look into <strong style="color: green">ctrl.copt</strong>. Two lines are important here:</p><pre><code>% const gfmode=1 c3=t
GF      MODE={gfmode} GFOPTS={?~c3~p3;~p2;}
</code></pre><p><strong>MODE={gfmode}</strong> means that you can define MODE in the command line by adding <strong>-vgfmode=1/10/11/26</strong>; if you don’t it will be set to 1 (from <strong>const gfmode=1</strong>). In the previous example we used <strong>MODE=1</strong> now we’ll need <strong>MODE=10</strong> that invokes a special branch computing magnetic exchange interactions using a linear response technique.</p> <div onclick="elm = document.getElementById('exchange'); if(elm.style.display == 'none') elm.style.display = 'block'; else elm.style.display = 'none';"><button type="button" class="button tiny radius">Heisenberg exchange parameters</button></div> <p><div style="display:none;margin:0px 25px 0px 25px;"id="exchange"></p> <p>The Heisenberg model is an empirical model that postulates a set of interacting rigid local spins. The Hamiltonian is</p> <script type="math/tex; mode=display">H = − \sum_{RR'} J_{RR'} S_RS_{R'}</script> <p>The <script type="math/tex">J_{RR'}</script> are called “Heisenberg exchange parameters”. The Heisenberg applies to a system of rigid spins undergoing small excursions about equilibrium. R and R’ are any pair sites and <script type="math/tex">J_{RR'}</script> is a kind of magnetic analog to the dynamical matrix describing small oscillations of nuclei around their equilibrium point. In a crystal with periodic boundary conditions <script type="math/tex">J_{RR'}</script> can be Bloch transformed to read:</p> <p><script type="math/tex">J_{RR'}(q) = \sum_T \exp(iqT) J_{R+T,R'}</script>, where R and R’ are now confined to sites within a unit cell.</p> <p><strong style="color: blue">lmgf</strong> calculates <script type="math/tex">J_{RR'}(q)</script> from the “Lichtenstein formula.” This famous expression (<a href="http://www.sciencedirect.com/science/article/pii/0304885387907219">J. Magn. Magn. Mater. 67, 65 (1987)</a>), closely related the static transverse magnetic susceptibility <script type="math/tex">\chi^{+−}</script>, is derived from density functional perturbation theory. It establishes a first-principles basis for the Heisenberg model. One elegant (though approximate) feature of the ASA is that the magnetization is everywhere associated with an atomic sphere. For local moment systems, the magnetization is well confined inside a sphere; thus associated with every site R there is a well defined local moment. If sufficiently localized it rotates rigidly under the influence of an external perturbation.</p> <p></div></p> <p>When you set <strong>GF_MODE=10</strong>, <strong style="color: blue">lmgf</strong> will generate <script type="math/tex">J_{RR'}(q)</script>, and then perform an inverse Bloch transform (by Fast Fourier Transform) to make <script type="math/tex">J_{R+T,R'}</script> for as many lattice translation vectors T as there are k-points.</p> <p><strong>Do</strong></p><pre><code>lmgf -vgfmode=10 ctrl.copt -vef=-.1289
</code></pre><p>Results are saved in file <strong style="color: green">jr.copt</strong> (see below).</p> <p>Most of the analysis is done in the next step, but already the output from <strong>gfmode=10</strong> contains some useful information. In the first of this pair of tables you see <strong>J_0</strong> and <strong>2/3 J_0</strong>. J_0 is the net Weiss magnetic field from the surrounding neighbors; 2/3 J_0 would be the (classical) mean-field estimate for the critical temperature <script type="math/tex">T_c</script> if there were one atom/cell. Since the Pt moment is very small it is weakly magnetic and has little effect on <script type="math/tex">T_c</script>. In the second table (<strong>J_0 resolved by L</strong>) J_0 is decomposed into lm contributions. As expected, the contributions to J_0 originates almost entirely from the d states.</p> <p>Now if you run <strong style="color: blue">lmgf</strong> with <strong>GF_MODE=11</strong>, it reads <strong style="color: green">jr.copt</strong> (which means you have to run <strong>MODE=10</strong> first) and does some analysis with the parameters. <strong>Invoke</strong> <strong style="color: blue">lmgf</strong> with</p><pre><code>lmgf -vgfmode=11 ctrl.copt -vef=-.1289
</code></pre><p>A unit cell of N sites has <script type="math/tex">N^2</script> pairs. Thus <strong style="color: green">jr.copt</strong> holds a succession of <script type="math/tex">N^2</script> tables of J, one array for each RR’ pair in the unit cell. Each array has <script type="math/tex">n_1n_2n_3</script> exchange parameters, corresponding to the lattice translation vectors that follow from the Fast Fourier Transform of a k mesh of <script type="math/tex">n_1n_2n_3</script> points. You can find the headers for each array (headers follow a standard format this package uses) by doing, e.g.</p><pre><code>grep rows jr.copt
</code></pre><p>to see:</p><pre><code>% rows 64 cols 8 real  rs  ib=1  jb=1
% rows 64 cols 8 real  rs  ib=1  jb=2
 ...
</code></pre><p>ach array has 64×8 entries, for T vectors derived from 8×8×8 k-points (the 3D array is stored in a 2D format). <strong style="color: blue">lmgf</strong> unpacks these (<strong>GFMODE=11</strong>) and prints them out in a sequence of tables, e.g. this one coupling all pairs of atoms belong to sites 2 and 3 in the unit cell. Pairs are ordered by separation distance d. Interactions fall off rapidly with d, and oscillate around 0, as might be expected from RKKY theory. Then follow estimates for the critical temperature <script type="math/tex">T_c</script>. <script type="math/tex">T_c</script> is estimated in Weiss mean-field theory, and also according to a spin-waves theory by Tyablikov (sometimes called the “RPA”). Mean-field tends to overestimate <script type="math/tex">T_c</script>; RPA tends to be a little more accurate but tends to underestimate it. From these two estimates <script type="math/tex">T_c</script> should be around 1000K (see the <strong>GFMODE=11</strong> output).</p> <p>Next follows an estimate for the spin wave stiffness. We need a symmetry lines file, let’s copy it from <strong style="color: green">/lm/startup/</strong> (make sure you have the correct path there. The folder has symmetry files for different structures, e.g. <strong style="color: green">syml.fcc</strong>, <strong style="color: green">syml.hcp</strong>, etc):</p><pre><code>cp startup/syml.sc syml.copt
</code></pre><p><strong style="color: blue">lmgf</strong> reads this file and calculates the spin wave spectrum from the Heisenberg model, along the lines specified. Results are saved in <strong style="color: green">bnds.copt</strong> (the energy scale is now mRy). So let’s <strong>run</strong> <strong>GFMODE=11</strong> again to get it (now we have the symmetry lines file):</p><pre><code>lmgf -vgfmode=11 ctrl.copt -vef=-.1289
</code></pre><p>You can plot magnon spectra using the same technology you use for plotting energy bands, see <a href="/tutorial/asa/lm_pbte_tutorial/">ASA-tutorial</a>. If you have the <strong style="color: blue">plbnds</strong> and <strong style="color: blue">fplot</strong> packages installed <strong>do</strong>:</p><pre><code>echo 0 350 5 10 | plbnds -scl=13.6 -fplot -lbl=X,G,M,R,G bnds.copt
fplot -f plot.plbnds
</code></pre><p>Now you have the <strong style="color: green">fplot.ps</strong> file with the spectra (you can rename this file to <strong style="color: green">some-name.ps</strong>) and use your favorite postscript reader to view it. You should see something close to what is shown in the figure:</p> <p><img src="http://lordcephei.github.io/images/magnon1.png" alt="magnon figure" height="300px" width="260px" />.</p> <p>Magnon energies are in meV.</p> <p><em>Note: The 8×8×8 mesh is a bit coarse. Use a finer k mesh for a smoother and more accurate magnon spectrum.</em></p> </article> </div><!-- /.medium-12.columns --> </div><!-- /.row --> <div id="up-to-top" class="row"> <div class="small-12 columns" style="text-align: right;"> <a class="iconfont" href="#top-of-page">&#xf108;</a> </div><!-- /.small-12.columns --> </div><!-- /.row --> <footer id="footer-content" class="bg-grau"> <div id="footer"> <div class="row"> <div class="medium-6 large-5 columns"> <h5 class="shadow-black">About This Site</h5> <p class="shadow-black"> Questaal is a suite of programs for LMTO and GW simulations. <a href="https://lordcephei.github.io/info/">More ›</a> </p> </div><!-- /.large-6.columns --> <div class="small-6 medium-3 large-3 large-offset-1 columns"> <h5 class="shadow-black">Services</h5> <ul class="no-bullet shadow-black"> <li > <a href="https://lordcephei.github.io" title=""></a> </li> <li class="services-contact" > <a href="https://lordcephei.github.io/contact/" title="Contact">Contact</a> </li> <li class="list" > <a href="https://lordcephei.github.io/developers/" title="Contact the developers">Developers</a> </li> </ul> </div><!-- /.large-4.columns --> <div class="small-6 medium-3 large-3 columns"> <h5 class="shadow-black">Related websites</h5> <ul class="no-bullet shadow-black"> <li > <a href="https://lordcephei.github.io" title=""></a> </li> <li class="network-entypo" > <a href="http://lmsuite.org" target="_blank" title="">Original LM Suite</a> </li> </ul> </div><!-- /.large-3.columns --> </div><!-- /.row --> </div><!-- /#footer --> </footer> <script src="https://lordcephei.github.io/assets/js/javascript.min.js"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-60112281-1', 'auto'); ga('set', 'anonymizeIp', true); ga('send', 'pageview'); </script> </body> </html>
