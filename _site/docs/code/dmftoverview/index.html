<!doctype html> <html class="no-js" lang="en"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>Implementation of the Dynamical Mean Field Theory</title> <link rel="stylesheet" href="https://lordcephei.github.io/assets/css/styles_feeling_responsive.css"> <script src="https://lordcephei.github.io/assets/js/modernizr.min.js"></script> <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script> <script> WebFont.load({ google: { families: [ 'Lato:400,700,400italic:latin', 'Volkhov::latin' ] } }); </script> <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script> <noscript> <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic|Volkhov' rel='stylesheet' type='text/css'> </noscript> <meta name="google-site-verification" content="KBbEPlf44q4dfL6SBHqymelMqXBSuZHSXIo-ZfkQLbE" /> <meta name="msvalidate.01" content="0FB4C028ABCF07C908C54386ABD2D97F" /> <meta name="description" content="Questaal is a suite of programs for LMTO and GW simulations."/> <link rel="author" href="https://plus.google.com/u/0/104386739373934968982"/> <link rel="icon" sizes="32x32" href="https://lordcephei.github.io/assets/img/favicon-32x32.png"> <link rel="icon" sizes="192x192" href="https://lordcephei.github.io/assets/img/touch-icon-192x192.png"> <link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://lordcephei.github.io/assets/img/apple-touch-icon-180x180-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://lordcephei.github.io/assets/img/apple-touch-icon-152x152-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://lordcephei.github.io/assets/img/apple-touch-icon-144x144-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://lordcephei.github.io/assets/img/apple-touch-icon-120x120-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://lordcephei.github.io/assets/img/apple-touch-icon-114x114-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://lordcephei.github.io/assets/img/apple-touch-icon-76x76-precomposed.png"> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://lordcephei.github.io/assets/img/apple-touch-icon-72x72-precomposed.png"> <link rel="apple-touch-icon-precomposed" href="https://lordcephei.github.io/assets/img/apple-touch-icon-precomposed.png"> <meta name="msapplication-TileImage" content="https://lordcephei.github.io/assets/img/msapplication_tileimage.png"/> <meta name="msapplication-TileColor" content="#fabb00"> <!-- Facebook Optimization --> <meta property="og:locale" content="en_EN" /> <meta property="og:type" content="website" /> <meta property="og:title" content="Implementation of the Dynamical Mean Field Theory" /> <meta property="og:description" content="Questaal is a suite of programs for LMTO and GW simulations."/> <meta property="og:url" content="https://lordcephei.github.io//docs/code/dmftoverview/" /> <meta property="og:site_name" content="Questaal" /> <!-- Search Engine Optimization --> <link type="text/plain" rel="author" href="https://lordcephei.github.io/humans.txt" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js", "AMSmath.js"], jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [ ['$','$'] ], displayMath: [ ['$$','$$'] ], processEscapes: true }, }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script> <style type="text/css"> red { color:purple; /*This changes the color of your text */ font-size:24pt; /*This changes the font size of your text */ } </style> </head> <body id="top-of-page" class="page-fullwidth"> <div id="navigation" class="sticky"> <nav class="top-bar" data-topbar> <ul class="title-area"> <li class="name"> <h1 class="hide-for-large-up"> <a href="https://lordcephei.github.io"> <img src="https://lordcephei.github.io/images/logo.png" style="width:125px;height:40px"></a></h1> </li> <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone --> <li class="toggle-topbar menu-icon"><a href="#"><span>Navigation</span></a></li> </ul> <section class="top-bar-section"> <ul class="left"> <li class ="show-for-large-up"><a href="https://lordcephei.github.io/"> <img src="https://lordcephei.github.io/images/logo.png" style="width:125px;height:40px"></a></li> <li class="divider"></li> <li class="has-dropdown"> <a href="https://lordcephei.github.io">Functionality</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/functionality/application/">By Physical Application</a></li> <li><a href="https://lordcephei.github.io/functionality/program/">By Suite Program</a></li> </ul> </li> <li class="divider"></li> <li class="has-dropdown"> <a href="https://lordcephei.github.io">Documentation</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/package_overview/">Package Overview</a></li> <li><a href="https://lordcephei.github.io/docs/install/">Installation</a></li> <li class="has-dropdown"><a href="#">Description by code</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/code/fpoverview/">Full Potential Overview</a></li> <li><a href="https://lordcephei.github.io/docs/code/gwoverview/">GW Overview</a></li> <li><a href="https://lordcephei.github.io/docs/code/dmftoverview/">Dynamical Mean Field Theory</a></li> <li><a href="https://lordcephei.github.io/docs/code/asaoverview/">ASA Overview</a></li> <li><a href="https://lordcephei.github.io/docs/code/lmgf/">ASA Green's function</a></li> <li><a href="https://lordcephei.github.io/docs/code/smhankels/">Smooth Hankel Functions</a></li> <li><a href="https://lordcephei.github.io/docs/code/jpos/">Jigsaw Puzzle Orbitals</a></li> <li><a href="https://lordcephei.github.io/docs/code/cpadoc/">CPA Enhancement of the Green's function package</a></li> <li><a href="https://lordcephei.github.io/docs/code/spectral-functions/">Spectral function calculations with lmgf</a></li> </ul></li> <li class="has-dropdown"><a href="#">Input Files</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/input/inputfile/">The Input File</a></li> <li><a href="https://lordcephei.github.io/docs/input/preprocessor/">File Preprocessor</a></li> <li><a href="https://lordcephei.github.io/docs/input/sitefile/">The Site file</a></li> <li><a href="https://lordcephei.github.io/docs/input/symfile/">Symmetry Line Files</a></li> </ul></li> <li class="has-dropdown"><a href="#">Annotated Output Files</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/outputs/lmf_output/">lmf standard output</a></li> </ul></li> <li class="has-dropdown"><a href="#">Command Line Options</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/commandline/general/">General</a></li> <li><a href="https://lordcephei.github.io/docs/commandline/lmf/">lmf</a></li> <li><a href="https://lordcephei.github.io/docs/commandline/lm/">lm</a></li> </ul></li> <li class="has-dropdown"><a href="#">Physical Properties</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/properties/optics/">Optics</a></li> </ul></li> <li class="has-dropdown"><a href="#">Auxilliary tools</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/docs/misc/plbnds/">The plbnds tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/pldos/">The pldos tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/fplot/">The fplot tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/mccalcdoc/">The mc calculator</a></li> <li><a href="https://lordcephei.github.io/docs/misc/pfitdoc/">The pfit tool</a></li> <li><a href="https://lordcephei.github.io/docs/misc/ccomp/">The ccomp processor</a></li> <li><a href="https://lordcephei.github.io/docs/misc/integerlists/">Integer list syntax</a></li> <li><a href="https://lordcephei.github.io/docs/misc/rotations/">Specifying rotations</a></li> </ul></li> </ul> </li> <li class="divider"></li> <li class="has-dropdown"> <a href="https://lordcephei.github.io">Tutorials</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/importing_input/">Importing Input files</a></li> <li class="has-dropdown"><a href="#">lmf</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_tutorial/">Basic Tutorial for Full-Potential lmf</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_pbte_tutorial/">Self-consistent density in PbTe</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_bi2te3_tutorial/">Properties of the lmf basis set</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/fpnew/">Elastic constant in Al</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/fpoptbas/">lmf Basis Set Optimisation</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/pdos/">Generating a Partial DOS</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/mulliken/">Performing Mulliken Analysis</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/fermisurface/">Generating a Fermi Surface</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/cls/">Performing Core Level Spectroscopy</a></li> <li><a href="https://lordcephei.github.io/tutorial/lmf/lmf_bandedge/">Extremal points and calculating effective mass</a></li> </ul></li> <li class="has-dropdown"><a href="#">ASA</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/asa/lm_pbte_tutorial/">LM Tutorial</a></li> </ul></li> <li class="has-dropdown"><a href="#">GW</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/gw/poscar_qsgw/">POSCAR to QSGW</a></li> <li><a href="https://lordcephei.github.io/tutorial/gw/qsgw_si/">Basic QSGW Tutorial: Si</a></li> <li><a href="https://lordcephei.github.io/tutorial/gw/qsgw_fe/">QSGW Tutorial for Fe</a></li> <li><a href="https://lordcephei.github.io/tutorial/gw/gw_self_energy/">The GW Self-energy and Spectral Function</a></li> </ul></li> <li class="has-dropdown"><a href="#">lmgf</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/lmgf/lmgf">LMGF Tutorial</a></li> </ul></li> <li class="has-dropdown"><a href="#">qsgw + dmft</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft0/">Introduction</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft1/">Setting up the DMFT loop</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft2/">Running the DMFT loop</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft3/">Issues with input and parameters</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft4/">Charge + static-magnetic contributions</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft5/">The density loop</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/maxent1/">The maximum entropy method</a></li> <li><a href="https://lordcephei.github.io/tutorial/qsgw_dmft/dmft7/">The self-energy loop and the dynamical double-counting</a></li> </ul></li> <li class="has-dropdown"><a href="#">tbe</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/tbe/tbectrl">TBE Tutorial</a></li> </ul></li> <li class="has-dropdown"><a href="#">Physical Application</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/application/optics/">Optics using lm and lmf</a></li> <li><a href="https://lordcephei.github.io/tutorial/application/fstut/">Making a Fermi surface</a></li> </ul></li> <li class="has-dropdown"><a href="#">Miscellaneous</a> <ul class="dropdown"> <li><a href="https://lordcephei.github.io/tutorial/misc/extbfield/">Adding external Zeeman field to the potential</a></li> </ul></li> </ul> </li> <li class="divider"></li> <li class=""><a href="https://lordcephei.github.io/formatting/">Site Contribution</a></li> <li class="divider"></li> <li class=""><a href="https://lordcephei.github.io/developers/">Developers</a></li> <li class="divider"></li> </ul> <ul class="right"> <li class="divider"></li> <li><a href="https://lordcephei.github.io/search/">Search</a></li> <li class="divider"></li> <li><a href="https://lordcephei.github.io/contact/">Contact</a></li> <li class="divider"></li> <li><a href="https://lordcephei.github.io/about/">About</a></li> </ul> </section> </nav> </div><!-- /#navigation --> <div class="row t30"> <div class="medium-12 columns"> <article> <header> <h1>Implementation of the Dynamical Mean Field Theory</h1> </header> <h3 class="no_toc" id="table-of-contents"><em>Table of Contents</em></h3> <hr /> <ul id="markdown-toc"> <li><a href="#preliminaries" id="markdown-toc-preliminaries"><em>Preliminaries</em></a></li> <li><a href="#introduction" id="markdown-toc-introduction"><em>Introduction</em></a></li> <li><a href="#building-the-dmft-hybridization-function---routine-lmfdmft" id="markdown-toc-building-the-dmft-hybridization-function---routine-lmfdmft"><em>Building the DMFT Hybridization Function - Routine lmfdmft</em></a> <ul> <li><a href="#input-files" id="markdown-toc-input-files"><em>Input Files</em></a> <ul> <li><a href="#input-files-a-brief-overview" id="markdown-toc-input-files-a-brief-overview"><em>Input Files: A Brief Overview</em></a></li> <li><a href="#indfml-file" id="markdown-toc-indfml-file"><em>indfml File</em></a></li> <li><a href="#siginp-file" id="markdown-toc-siginp-file"><em>sig.inp file</em></a></li> </ul> </li> <li><a href="#the-lmfdmt-cycle-and-its-main-subroutine-sudmftf" id="markdown-toc-the-lmfdmt-cycle-and-its-main-subroutine-sudmftf"><em>The lmfdmt cycle and its main subroutine: sudmft.f</em></a> <ul> <li><a href="#new-feature-total-qsgwdmft-charge-density" id="markdown-toc-new-feature-total-qsgwdmft-charge-density"><em>New feature: Total QSGW+DMFT charge density</em></a></li> </ul> </li> <li><a href="#output-files" id="markdown-toc-output-files"><em>Output Files</em></a></li> </ul> </li> <li><a href="#extracting-the-impurity-self-energy---ctqmc-software" id="markdown-toc-extracting-the-impurity-self-energy---ctqmc-software"><em>Extracting the Impurity Self-Energy - CTQMC Software</em></a> <ul> <li><a href="#input-files-and-scripts" id="markdown-toc-input-files-and-scripts"><em>Input Files and Scripts</em></a> <ul> <li><a href="#the-params-file" id="markdown-toc-the-params-file"><em>The PARAMS File</em></a></li> <li><a href="#treating-d-systems-the-script-atomdpy-and-the-file-transdat" id="markdown-toc-treating-d-systems-the-script-atomdpy-and-the-file-transdat"><em>Treating d-systems: the script atom_d.py and the file Trans.dat</em></a></li> <li><a href="#the-deltainp-and-eimpinp-input-files" id="markdown-toc-the-deltainp-and-eimpinp-input-files"><em>The Delta.inp and Eimp.inp Input Files</em></a></li> <li><a href="#the-broadsigf90-script" id="markdown-toc-the-broadsigf90-script"><em>The broad_sig.f90 Script</em></a></li> </ul> </li> <li><a href="#outputs-of-ctqmc" id="markdown-toc-outputs-of-ctqmc"><em>Outputs of CTQMC</em></a></li> <li><a href="#bonus-track-a-fully-inclusive-interface" id="markdown-toc-bonus-track-a-fully-inclusive-interface"><em>Bonus Track: A Fully Inclusive Interface</em></a></li> </ul> </li> <li><a href="#references" id="markdown-toc-references"><em>References</em></a></li> </ul> <h3 class="no_toc" id="purpose"><em>Purpose</em></h3> <hr /> <p>This manual is meant to give the guidelines and a reference for one of the several packages of the Questaal Suite, the one responsible for the execution of a QSGW+DMFT calculation from first principles.</p> <h3 id="preliminaries"><em>Preliminaries</em></h3> <hr /> <p>In what follows a basic user’s background on electronic structure methods, in particular Density Functional Theory, GW methods and DMFT, as well as the LMTO basis set, is assumed. For an overview of the theory, and in particular a specific account of the equations used in the implementation, we will refer to Paolo Pisanti’s PhD thesis [2], whose browsing is advised when reading this document.</p> <p>The user is also advised to have a basic understanding of the lmf code and familiarity with its usage. For this purpose we refer to <a href="/tutorial/lmf/lmf_tutorial/">lmf tutorial</a>. In particular, this manual has to be considered complementary to a specific tutorial written by Lorenzo Sponza which can be found <a href="/tutorial/qsgw_dmft/dmft0/">here</a> and whose reading is incouraged.</p> <h3 id="introduction"><em>Introduction</em></h3> <hr /> <p>A schematic flowchart clarifying the structure of the software and the main routines involved in the QSGW+DMFT loop is presented in the figure below. For a formal introduction on DMFT, its assumptions, main equations and key quantities into play we refer to chapter 3, section 3.1 of [2]. The details of our specific implementation of the QSGW+DMFT scheme are instead presented in chapter 4 of [2]. In particular in the next two chapters we will refer to the equations of section 4.2 and 4.3 to illustrate the several steps of the implementation and the different subroutines.</p> <p>In chapter 1 we will introduce the structure, main input and output files of the <strong style="color: blue">lmfdmft</strong> routine (blue box in the image below). The object of this routine is the calculation, from first principles and using as inputs the results of a converged QSGW (or DFT) loop, of the so-called hybridization function $\Delta(\omega)$, defined in DMFT to capture the coupling of the impurity with the surrounding bath in which is embedded. The key steps for such a purpose will be to define and calculate a projection operator to the correlated local subset, employ this operator to define local quantities such as local Green’s function and impurity levels, correct the eigenvalues with the embedded impurity self-energy injection, and tune the chemical potential accordingly.</p> <p>In chapter 2 we will present the Continuous Time Quantum-Monte Carlo (CTQMC) impurity solver (red box in the image below), whose main operation is the calculation of the impurity self-energy <script type="math/tex">\Sigma^\text{imp}(\omega)</script>. The software has been implemented by Kristjan Haule at Rutgers University and it was originally part of his Wien2k-DMFT code [1]. It has been isolated in such a way to work in connection with the LMTO suite in a QSGW+DMFT implementation. The CTQMC solver takes the hybridization function $\Delta(\omega)$ and the impurity level $E^\text{imp}(\omega)$ originating from the <strong style="color: blue">lmfdmft</strong> loop as main inputs, together with the effective interactions parameters $U,J$. These parameters are tuned with respect to the material under study and they are typically specific to the DMFT implementation and the solver adopted.</p> <p><img src="/assets/img/inout_dmftloop.svg" alt="I/O in the DMFT Loop" /></p> <p>The flowchart of the main routines of the present QSGW+DMFT implementation. The new interface (lmfdmft routine) has been singled out in a red box. This interface connects the main LMTO suite package to the CTQMC solver of DMFT. Image created by Lorenzo Sponza. The gold and green boxes appearing in the image represent the other programs necessary to complete the interface between the two packages. They will also be object of 2nd chapter.</p> <h3 id="building-the-dmft-hybridization-function---routine-lmfdmft"><em>Building the DMFT Hybridization Function - Routine lmfdmft</em></h3> <hr /> <p>This chapter is focused on the first block of the DMFT cycle, the calculation (and update) of the <em>hybridization function</em> from the inputs of a converged QSGW (or DFT) calculation. This operation is performed by the routine, part of the Full-Potential package.</p> <p>A tutorial written by L. Sponza to run a full QSGW+DMFT calculation and in particular the executable can be found at this <a href="/tutorial/qsgw_dmft/dmft1">link</a>.</p> <h4 id="input-files"><em>Input Files</em></h4> <p>In this section an overview of the input files required and their syntax will be presented. The starting point of the DMFT loop are the results of a converged QSGW (or either a DFT) calculation, executed with the package.</p> <p>In order to keep consistence with the tutorial, we will refer to <em style="color: green">lmfinput/</em> as the routine containing the original input files and <em style="color: green">it#_lmfrun/</em> as the routine containing the #-th iteration of <strong style="color: blue">lmfdmft</strong>.</p><pre><code>$ ls -l lmfinput
ctrl.case
site.case
rst.case
sigm.case

indmfl.case
sig.inp
</code></pre><p>An experience user will notice that the first 4 files are regular files belonging to the full-potential package, those are the results of the converged QSGW loop. For a specific discussion of these files, we refer to this <a href="/tutorial/lmf/lmf_tutorial/">tutorial</a> for <strong style="color: blue">lmf</strong>. The last 2 files (<em style="color: green">indmf1.case</em> and <em style="color: green">sig.inp</em>) are instead specific of the <strong style="color: blue">lmfdmft</strong> program and they are used just in DMFT cycles.</p> <h5 id="input-files-a-brief-overview"><em>Input Files: A Brief Overview</em></h5> <p>The is the main input file of, for a full documentation read <a href="/docs/input/inputfile/">here</a>. In order to process this input file in a QSGW+DMFT calculation, one line has to be added to the input file resulting from the QSGW loop, this can be done by means of the following command</p><pre><code>echo 'DMFT    PROJ=2 NLOHI=11,53 BETA=50 NOMEGA=1999 KNORM=0' &gt;&gt; ctrl.case}.
</code></pre><p>The token <em>DMFT_PROJ</em> refers to the kind of projection operation, n.2 corresponds to equation (4.6) of [2]. No other option is advised at state of the art. The token <em>DMFT_NHOLI</em> defines the energy window in which the DMFT projection operator is included. In particular the first number refers to the first band to be included, lower bound of the window and the second number to the last band, upper bound. This energy window is supposed to include the contributions from the correlated subset of orbitals chosen (say, the $3d$-orbitals of Cu), as well as the contributions from orbitals which these bands are hybridized with (e.g. typically in copper oxides, the O $2p$-levels). We refer to section 4.1 of [2] for a guideline on the origin of this energy window and how to use it. The choice of the correct energy window should be inferred by looking at the QSGW bandstructure of the solid and in particular the $\Gamma$ point. The token <em>DMFT_BETA</em> refers to the inverse temperature, in units of eV$^{-1}$, <em>DMFT_NOMEGA</em> to the total number of points of the Matsubara frequency mesh on which the dynamical impurity quantities are defined. <em>DMFT_KNORM</em> is a token related to the kind of renormalization to apply to the projection operator, the value of 0 related to eq.(4.8) of [2] and the value of 1 to the eq. following eq.(4.9), but the second option is strongly discouraged and it will probably be eliminated.</p> <p>The file <em style="color: green">site.case</em> displays the atom type and coordinates of the single cell, no modification with respect to the file adopted in <strong style="color: blue">lmf</strong>. This file can also be incorporated in the <em style="color: green">ctrl.case</em> file by listing it under the token <em>SITE</em>. In the case of magnetic calculations, a <em style="color: green">site2.case</em> with the coordinates related to the super-cell is usually employed instead, with the switch _-vfile=2_to be added to the command line.</p> <p>The file <em style="color: green">rst.case</em> contains the charge density of the system.</p> <p>The content of <em style="color: green">sigm.case</em> file is the QSGW self-energy scaled by the exchange-correlation potential in such a way to eliminate this contribution when updating the Hamiltonian. For this reason when no <em style="color: green">sigm.file</em> file is found the exchange-correlation potential will be read automatically and a DFT+DMFT loop will be carried on.</p> <h5 id="indfml-file"><em>indfml File</em></h5> <p>The <em style="color: green">indfml.case</em> is the key input file in <strong style="color: blue">lmfdmft</strong>, containing all the parameters required to run the DMFT loop starting from QSGW inputs. It was originally part of K. Haule’s Wien2k-DMFT code [1] and therefore it still contains features which are not meaningful in this implementation. It can be generated by the script <strong style="color: blue">init_dmft.py</strong> taking the <em style="color: green">ctrl.case</em> file as as input or it can be simply copied from other calculations and revised. An example:</p><pre><code>#---- Example of indmfl file---
0.1 1.2 1 2                # hybridization Emin and Emax, measured from FS, renormalize for interstitials, projection type
1 0.0025 0.0025 600 -3.000000 1.000000  # matsubara, broadening-corr, broadening-noncorr, nomega, omega_min, omega_max (in eV)
1                                     # number of correlated atoms
1     1   0                           # iatom, nL, locrot
  2   2   1                           # L, qsplit, cix
#================ # Siginds and crystal-field transformations for correlated orbitals ================
1     5  5       # Number of independent kcix blocks, max dimension, max num-independent-components
1     5  5       # cix-num, dimension, num-independent-components
#---------------- # Independent components are --------------
'x^2-y^2' 'z^2' 'xz' 'yz' 'xy'
#---------------- # Sigind follows --------------------------
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5
#---------------- # Transformation matrix follows -----------
 0.70710679 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.70710679 0.00000000
 0.00000000 0.00000000   0.00000000 0.00000000   1.00000000 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000
 0.00000000 0.00000000   0.70710679 0.00000000   0.00000000 0.00000000  -0.70710679 0.00000000   0.00000000 0.00000000
 0.00000000 0.00000000   0.00000000 0.70710679   0.00000000 0.00000000   0.00000000 0.70710679   0.00000000 0.00000000
-0.70710679 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.70710679 0.00000000
</code></pre><p>Let us review the content block by block.</p><pre><code>0.1 1.2 1 2                \# hybridization Emin and Emax, measured from FS, renormalize for interstitials, projection type}
</code></pre><p>The first 2 entries indicate the minimum and maximum values for the energy window entering the projector. These values are calculated from the eigenvalues at the $\Gamma$ point in correspondence of the bands indicated in the <em>DMFT_NLOHI</em> token of the <em style="color: green">ctrl.case</em> file. The 3rd value regards a normalization option for the interstitials which is not taken into account in this code and the 4th entry is equivalent to the token <em>DMFT_PROJ</em> of <em style="color: green">ctrl.case</em>.</p><pre><code>1 0.0025 0.0025 600 -3.000000 1.000000  \# matsubara, broadening-corr, broadening-noncorr, nomega, omega\_min, omega\_max (in eV)
</code></pre><p>The first entry is a switch for Matsubara frequencies (1 for true, 0 for false), but the impurity solver does not handle real frequencies so only the option 1 is advised. The 2nd and 3rd values are broadening parameters not taken into account. The same can be said about the 4th, 5th and 6th entry, controlling # of frequency points, minimum and maximum frequency.</p><pre><code>1                                     # number of correlated atoms
1     1   0                           # iatom, nL, locrot
  2   2   1                           # L, qsplit, cix
</code></pre><p>This block defines the local subset of correlated orbitals chosen <br /> First line: the 1st entry indicates the total number of different correlated atoms (equivalent or non-equivalent ones). <br /> Second line: there will be a line like this for each of the correlated atoms specified at the line before (just 1 in this case). The index <em>iatom</em> points to the specific atom chosen with respect to the legend in the <em style="color: green">site.case</em> file, <em>nL</em> to the number of different orbital characters for this atom (e.g. for both $p$,$d$ Copper orbitals <em>nL</em> would be 2) and is a flag controlling local rotations (1 or 0). <br /> Third line: specifications for atom of the previous line. gives the value of the angular momentum (orbital $d$ in this case), <em>qsplit</em> refers to the Harmonic orbitals basis in which the projector and hybridization function are written, <em>cix</em> indicates the correlated block which this correlated set of orbitals belongs to. If orbitals of different character are included in the same block they will all be listed in the same file for the hybridization function and impurity self-energy. In this case the user will have the possibility of handling matrix elements (referring to the indices $LL’$ of section 4.1 of [2]) of mixed character, say, Oxigen-2$p$ and Copper-3$d$ for what regards the local functions.</p><pre><code>#================ # Siginds and crystal-field transformations for correlated orbitals ================
1     5  5       # Number of independent kcix blocks, max dimension, max num-independent-components
1     5  5       # cix-num, dimension, num-independent-components
</code></pre><p>This block gives indications regarding the correlated blocks included. The first line is a comment line. The entries at the second and third line define the same quantities except the second line refers to the maximum values for all the correlated blocks included and the second line for the specific block considered (in this case they are equivalent having selected just one block of orbitals). The 3 entries indicate the block index, its dimension (which corresponds to the value of $2\ell+1$) and the number of independent components (in the case of degeneracy this number is smaller than the dimension of the matrix).</p><pre><code>#---------------- # Independent components are --------------
'x^2-y^2' 'z^2' 'xz' 'yz' 'xy'
</code></pre><p>This block is just explanatory and not read in the code. The second line gives the $m$-character order of orbital components of the $L$ index, with $2\ell+1=5$ in the case of $d$-shells.</p><pre><code>#---------------- # Sigind follows --------------------------
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5
</code></pre><p>This block refers to the matrix elements of the impurity self-energy contained in the <em style="color: green">sig.inp</em> file. It indicates the matrix of components in the $LL’$ basis following the notation of the previous block. In this example just the diagonal matrix elements are included with no degeneracy. <br /> A typical case of degeneracy in 3$d$ systems reduces the total number of components to 3 with the matrix looking like</p><pre><code>#---------------- # Transformation matrix follows -----------
 0.70710679 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.70710679 0.00000000
 0.00000000 0.00000000   0.00000000 0.00000000   1.00000000 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000
 0.00000000 0.00000000   0.70710679 0.00000000   0.00000000 0.00000000  -0.70710679 0.00000000   0.00000000 0.00000000
 0.00000000 0.00000000   0.00000000 0.70710679   0.00000000 0.00000000   0.00000000 0.70710679   0.00000000 0.00000000
-0.70710679 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.00000000 0.00000000   0.70710679 0.00000000
</code></pre><p>This last block gives the transformation matrix from the harmonic basis chosen to complex spherical harmonics. It is another feature of Wien2k-DMFT code, not used in. A unitary transformation of this matrix (according to Kristjan’s Haule notation) gives the matrix appearing in the file which on the contrary is employed and will be described later. <br /> The reader will find a more extensive example of a indmfl file <a href="assets/download/examples/indmflex.lsco">here</a> in the case of super-cell and different blocks of correlated orbitals, the corresponding super-cell site file is <a href="assets/download/examples/siteex.lsco">here</a>.</p> <h5 id="siginp-file"><em>sig.inp file</em></h5> <p>The <em style="color: green">sig.inp</em> file contains the impurity self-energy resulting from the impurity solver. Specifically it is obtained from the file <em style="color: green">Sig.out</em> resulting from the <em>CTQMC</em> solver and applying an operation of broadening to it as explained <a href="/tutorial/qsgw_dmft/dmft2/">here</a>. It is read in <strong style="color: blue">lmfdmft</strong> to update the local Green’s function and the hybridization function after an operation of embedding of the local impurity self-energy. The structure of this file is the following: a first column listing the values of Matsubara frequencies included (as many values as the token <em>DMFT_NOMEGA</em> indicates), and the other columns listing the complex values of $\Sigma^\text{imp}$ in the order and total number indicated in the block of the file (see previous section). An example of the first lines (referred to the convention of the of the previous section):</p><pre><code>#---- Example of siginp file (after several iterations)---
# broad_sig.f90 : input parameters = Sig.out  230  l  (55  20  230)  k  (1 2 3 2 3)
    0.06283185      78.23564148   -0.04490779      78.62860107   -0.03800205      80.56986618   -0.45687344      78.62860107   -0.03800205      80.56986618   -0.45687344
    0.18849556      78.22446442   -0.13346720      78.61967087   -0.11252947      80.72179031   -0.74727110      78.61967087   -0.11252947      80.72179031   -0.74727110
    0.31415927      78.20281219   -0.21841954      78.60257339   -0.18401078      80.78148651   -0.94496335      78.60257339   -0.18401078      80.78148651   -0.94496335
    0.43982297      78.17199707   -0.29778469      78.57825470   -0.25096695      80.76762009   -1.11261369      78.57825470   -0.25096695      80.76762009   -1.11261369
    0.56548668      78.13374329   -0.37015086      78.54793167   -0.31232700      80.72345734   -1.26635915      78.54793167   -0.31232700      80.72345734   -1.26635915
</code></pre><p>The total number of column is 11. The first one lists the frequencies, the other 10 are the complex values (real and imaginary part) of the self-energies related to the 5 components of the $d$-orbitals (as indicated by the <em>sigind</em> matrix). <br /> At the first iteration the self-energy is null, therefore the only non-zero column will be the first one listing the frequencies. The user will not need to prepare a blank file for the first iteration. When <strong style="color: blue">lmfdmft</strong> is executed a suitable file will automatically be created. The <strong style="color: blue">lmfdmft</strong> command will then have to be called twice in the first iteration, one to create the zero <em style="color: green">siginp</em> file, and a second one for the actual execution of the first loop.</p> <h4 id="the-lmfdmt-cycle-and-its-main-subroutine-sudmftf"><em>The lmfdmt cycle and its main subroutine: sudmft.f</em></h4> <p>This section will be dedicated to a focus on the of the <strong style="color: blue">lmfdmft</strong> executable, with a description of its key steps together with the corresponding subroutines. We will refer to sections 4.2 and 4.3 of [2] and in particular Figures 4.1 and 4.2 for reference. <br /> The main body of <strong style="color: blue">lmfdmft</strong> is the <strong style="color: blue">sudmft.f</strong> subroutine, this is a list of its main steps (with a reference to the subroutines executing the several operations):</p> <ul> <li> <p>Read the <em style="color: green">indmfl</em> file and store the parameters needed to build the projector. This operation is carried on by routine.</p> </li> <li> <p>Read the charge density from the <em style="color: green">restart</em> file, the QSGW self-energy from the <em style="color: green">sigm</em> file (when no <em style="color: green">sigm</em> file is found a LDA calculation is assumed) and diagonalize the QSGW Hamiltonian to return a set of quasi-particles eigenvalues and eigenvectors (see top block of Fig.4.2) in the FP-LMTO basis (introduced in sec. 4.1.1.1). <br /> This operation is carried on by routine. It is the first conceptual step of the DMFT loop, repeated for each iteration but with the same results. This is because the QSGW Hamiltonian and eigenvalues are frozen, whereas the other quantities are updated up to DMFT convergence.</p> </li> <li> <p>Read the impurity self-energy file <em style="color: green">siginp</em> and store the content in an array. This operation is carried on by <strong style="color: blue">readsiginp</strong> routine. At the first iteration <em style="color: green">siginp</em> is null and the code will recognize not to take any double-counting into account.</p> </li> <li> <p>Construct the un-normalized DMFT projection operator (eq. (4.6)), by routine . Build the overlap matrices Olapm and use those to renormalize the projectors (eq. (4.8)), this operation follows the call of <strong style="color: blue">makeproj</strong> in <strong style="color: blue">sudmft</strong> . The projector is then dumped to disk.</p> </li> <li> <p>Embed the impurity self-energy from the local into the full-space basis using the projector just generated (according to eq.(4.3b)) and remove the DC contribution (eq.(4.23)). This operation is carried on by <strong style="color: blue">embed_sigma</strong> routine.</p> </li> <li> <p>Tune and update the chemical potential. This operation in quite elaborate, we refer to sec.4.4.3 for details. It requires the diagonalization of the Hamiltonian over all Matsubara frequencies after updating it with the embedded impurity self-energy (routines <strong style="color: blue">makehbar2</strong> and <strong style="color: blue">agonham</strong>). The following step is to update the valence charge from the corresponding dynamical eigenvalues (routine <strong style="color: blue">cmpvalcharg_matsub4</strong>). Finally determine the correct correction $V$ to the chemical potential in such a way to return the correct electron number (routine <strong style="color: blue">getVnew</strong>).</p> </li> <li> <p>Define the local functions by means of the projection operator and the correction from the embedded impurity self-energy. The local Green’s function (eq. (4.24)) is generated by routine <strong style="color: blue">makegloc2</strong> and the impurity levels (eq. (4.25)) by routine <strong style="color: blue">makeeimp</strong>. These functions are both written to disk.</p> </li> <li> <p>Build the Hybridization function (according to eq. (4.19)) and store it into disk. This operation is carried on by <strong style="color: blue">makedelta3</strong> routine.</p> </li> </ul> <h5 id="new-feature-total-qsgwdmft-charge-density"><em>New feature: Total QSGW+DMFT charge density</em></h5> <p>The steps just summarized are the key features of routine, representing the first block of the DMFT cycle (the second block is the object of next chapter), they are therefore repeated for each iteration of the cycle. <br /> When DMFT convergence is reached the <strong style="color: blue">lmfdmft</strong> executable can be adopted with a specific flag to extract the total charge density, updated by means of the converged impurity self-energy. This procedure is carried on following the prescription of [1], and it is a recent implementation coded by L.Sponza. For a review of this operation, together with the routines of <strong style="color: blue">lmfdmft</strong> responsible for its execution, we refer to section 6.3 of this <a href="assets/download/docs/sponza-notes.pdf">manual</a> written by L. Sponza.</p> <h4 id="output-files"><em>Output Files</em></h4> <p>In this section we present an overview of the main output files of the <strong style="color: blue">lmfdmft</strong> cycle. They will be the content of the so-called <em style="color: green">it#_lmf</em> folder, where the # stands for the given iteration. The iterations following the first one use as input the impurity self-energy resulting from the <em>CTQMC</em> solver, object of next chapter. Here we present the simple case of the output files of the first iteration.</p><pre><code>#---- Output of lmfdmft run (in chronological order)---
evec.case
wkp.case
moms.case
proj.case
delta.case
eimp1.case
gloc.case
log.case
log
</code></pre><p>The first three files are regular outputs of <strong style="color: blue">lmf</strong>, binary files containing respectively the eigenalues (<em>evec</em>), information regarding the $k$-point mesh (<em>wkp</em>) and momentum (<em>moms</em>). They are temporary inputs used to produced the other outputs and they are not taken as inputs in the following steps of the DMFT cycle. <br /> The <em style="color: green">proj.case</em> file is another binary output storing the DMFT projection operator. It is generated and stored to disk on the fly and then read to define the local functions. <br /> The <em style="color: green">gloc.case</em> is instead an ASCII file, containing the local correlated Green’s function $G^\text{loc}<em style="color: green">{LL’}(\omega_n)$ as a function of Matsubara frequencies. The file structure is the same as for the _sig.inp</em> file, with as many columns as the correlated orbitals selected in the <em>Sigind</em> block of the <em style="color: green">indmfl</em> file. The <em style="color: green">gloc.case</em> is not taken as input by other routines but it is a useful reference for other operations (such as the analytic continuation). <br /> The files <em style="color: green">delta.case</em> and <em style="color: green">eimp1.case</em> are ASCII files representing the key output of <strong style="color: blue">lmfdmft</strong>. They are taken as input by the <em>CTQMC</em> impurity solver. <br /> What said about the <em style="color: green">gloc.case</em> file’s structure is equivalent for <em style="color: green">delta.case</em>, storing the hybridization function in the correlated local basis. The <em style="color: green">eimp1.case</em> file contains instead the impurity levels and the double-counting constant used. The file has a composite structure tailored to be parsed by the scripts of the interface in the <em>CTQMC</em> solver. An example:</p><pre><code>#---- Example of eimp1.case file---
Edc=[  25.500000,  25.500000,  25.500000,  25.500000,  25.500000,  25.500000,  25.500000,  25.500000,  25.500000,  25.500000]  # Double counting
Eimp=[   0.326716,   0.393662,   0.061104,   0.460181,   0.061165,   0.326705,   0.393612,   0.061085,   0.460140,   0.061127] # Eimp: P.(e+E.sbar)-sinp-mu+Edc
Eimp=[   0.000000,   0.066946,  -0.265612,   0.133464,  -0.265551,  -0.000011,   0.066895,  -0.265631,   0.133423,  -0.265589] # Eimp: shifted by Eimp[0]
Ed [ -25.173284, -25.106338, -25.438896, -25.039819, -25.438835, -25.173295, -25.106388, -25.438915, -25.039860, -25.438873] # Ed: Eimp-Edc for PARAMS
mu   25.173284 # mu = -Eimp[0] for PARAMS
</code></pre><p>The <em style="color: green">log</em> file shows the several passages of the routine summarized in the previous section. Let us review a portion of its content (in the case of the first iteration for zero <em style="color: green">sig.inp</em>).</p><pre><code>#---- First block of log file---
iors  : read restart file (binary, mesh density) 
use from  restart file: ef window, positions, pnu 
ignore in restart file: *
</code></pre><p>from which we know that the <em style="color: green">restart</em> file containing the charge density has been correctly read.</p><pre><code>#---- Second block of log file---
 ... sudmft job=1: make projectors
 Reading indmfl file ... 1 total (1 inequivalent) correlated blocks, among 1 sites
 readindmfl: 5 nonzero (5 inequivalent) matrix elements

   channels for 2nd spin block
   m1   m2   cix chn(1) chn(2)
    1    1    1     1     6
    2    2    1     2     7
    3    3    1     3     8
    4    4    1     4     9
    5    5    1     5    10

  correlated channels:
  chan equiv m1   m2   isp icix  cix  ib
    1    1    1    1    1    1    1    1
    2    2    2    2    1    1    1    1
    3    3    3    3    1    1    1    1
    4    4    4    4    1    1    1    1
    5    5    5    5    1    1    1    1
    6    6    1    1    2    1    1    1
    7    7    2    2    2    1    1    1
    8    8    3    3    2    1    1    1
    9    9    4    4    2    1    1    1
   10   10    5    5    2    1    1    1
 
 indmfl file expects 1 DMFT block(s) (max dimension 5),  10 matrix elements
</code></pre><p>This section corresponds to the creation of projection operators after reading the <em style="color: green">indfml</em> file. It gives direct infos about the correlated blocks of orbitals chosen and their character. In this case we notice how 10 channels are produced from a block of 5 in the <em style="color: green">indmfl</em> file since the calculation is magnetic and the spin is 2.</p><pre><code>#---- Third block of log file---
 Reading DMFT sigma from file ...
         DMFT sigma is zero ... no double counting

 SUDMFT: projector #2 with k-integrated norm.  8 bands in window (4,11)
         2000 Matsubara frequencies, interval (0.0628318,251.265) eV
         User-specified double-counting in eV : --ldadc=25.5
</code></pre><p>First part: being this the first iteration the file <em style="color: green">sig.inp</em> is null, the code recognizes it and no DC is included. Second part: general infos about the projector before these are renormalized, the Matsubara mesh, the energy window chosen and the DC calculated according to (4.29) of [2] by reading the values specified as inputs for Hubbard parameters $U,J$ and the the nominal occupancy of the correlated orbitals $n_f$.</p><pre><code>#---- Fourth block of log file---
 BNDFP:  Write evals,evecs to file for 29 qp
 bndfp:  kpt 1 of 29, k=  0.00000  0.00000  0.00000
 -3.8973 -3.8973 -3.8973 -0.5804 -0.1352 -0.1352 -0.1352 -0.0280 -0.0280
 bndfp:  kpt 1 of 29, k=  0.00000  0.00000  0.00000
 -3.8973 -3.8973 -3.8973 -0.5804 -0.1352 -0.1352 -0.1352 -0.0280 -0.0280
</code></pre><p>Here a first portions of the eigenvalues generated by routine and stored in <em style="color: green">evec.case</em> is reported. Being a magnetic calculation we notice the same $k$-points contribution being listed twice (for majority and minority spin components). In this case the eigenvalues are identical since the magnetic moment is initially null.</p><pre><code>#---- Fifth block of log file---
 Renormalize projectors ...

 Find chemical potential mu...
 Seek mu for 14 electrons ... 13.842564 electrons at Ef0=-0.026874.  D(Ef0)=57.196
 getVnew: v1=0e0 N1=-1.574e-1  v2=-2.753e-3 N2=-5.867e-3  bracket=F  est=-0.00286977
 getVnew: v1=-2.753e-3 N1=-5.867e-3  v2=-2.87e-3 N2=1.382e-4  bracket=T  est=-0.00286707
 getVnew: v1=-2.87e-3 N1=1.382e-4  v2=-2.867e-3 N2=-4.814e-8  bracket=T  est=-0.00286707
 mu = -0.024006 = Ef0--0.002867.  Deviation from neutrality = -9.59e-14
 Electron charge:  14.000000   moment:  0.000000    spin resolved DOS:    25.553  25.553
</code></pre><p>After the projector are renormalized, the chemical potential finder is run. In this case 3 iterations are sufficient to converge to the correct value for the electron count, the correction $V$ to $mu$ is stored.</p><pre><code>#---- Sixth block of log file---
  Make gloc, delta, eimp ...
 Writing files delta and eimp1 ...

 Check SC condition skipped (missing information about previous iteration)
 gloc(N)   recorded in gloc.ext file.
 Exit 0 done making DMFT hybridization function 
</code></pre><p>Last block of the <em style="color: green">log</em> file. The local functions are generated and written to disk. Being this the first iteration no DMFT self-consistent condition can be met.</p> <h3 id="extracting-the-impurity-self-energy---ctqmc-software"><em>Extracting the Impurity Self-Energy - CTQMC Software</em></h3> <hr /> <p>This chapter will be dedicated to the second (and last) block of the DMFT cycle, the employment of the QSGW-based hybridization function to extract the impurity self-energy of DMFT by means of the impurity solver (see sec.31 of [2] for the details of the equations and main quantities into play). <br /> In practice this operation pivots on two main programs, the <em>CTQMC</em> (Continuous Time quantum Monte-Carlo) impurity solver and the interface connecting this program with the other block (i.e. the <strong style="color: blue">lmfdmft</strong> routine) completing the DMFT cycle. The <em>CTQMC</em>, mainly written in C++ code, is a program developed by K. Haule as part of his Wien2k-DMFT code [1] and which has been adapted in this implementation. The next section will mainly focus on the interface between the <strong style="color: blue">lmfdmft</strong> routine and the solver, the main inputs and scripts required, and a brief overview of the output files. <br /> This chapter is complementary to this <a href="/tutorial/qsgw_dmft/dmft2">tutorial</a> by L. Sponza which provides detailed instructions on how to run the <em>CTQMC</em> software, with some more insight into the scripts and some tips on how to set the correct parameters.</p> <h4 id="input-files-and-scripts"><em>Input Files and Scripts</em></h4> <p>In this section we will provide a summary of the overall input files required for both the interface and the <em>CTQMC</em> software, together with the main scripts needed. <br /> The folder containing the main input files and scripts is generally called <em style="color: green">qmcinput</em>. In order to be consistent with the notation of the previous chapter we will refer to <em style="color: green">it#_qmcrun</em> for the folders containing the several iterations of <em>CTQMC</em>. It is useful to review the input files for both folders.</p><pre><code>$ ls -l qmcinput
atom_d.py
broad_sig.f90
Trans.dat
PARAMS

$ ls -l it#_qmcrun
#output of atom_d.py 
info_atom_d.dat
actqmc.cix
new.cix
#output of previous lmfdmft run
Delta_in -&gt; ../it#_lmfrun/delta.fe
Delta.inp
Eimp_in -&gt; ../it#_lmfrun/eimp1.fe
Eimp.inp
</code></pre><p>The files contained in <em style="color: green">qmcinput</em> are frozen for all the iterations whereas the ones in <em style="color: green">it#_qmcrun</em> are updated for each iteration.</p> <h5 id="the-params-file"><em>The PARAMS File</em></h5> <p>The <em style="color: green">PARAMS</em> file is the key input file of <em>CTQMC</em>. The correct choice for the parameters listed in this file can affect quite significantly the quality of the calculation. For this reason, the user is highly encouraged to read this <a href="/tutorial/qsgw_dmft/dmft3">tutorial</a> on how to set the most important parameters. <br /> An example:</p><pre><code>#---- Example of PARAMS file---
Ntau  1000
OffDiagonal  real
Sig  Sig.out
Naver  100000000
SampleGtau  1000
Gf  Gf.out
Delta  Delta.inp
cix  actqmc.cix
Nmax  700     # Maximum perturbation order allowed
nom  150      # Number of Matsubara frequency points sampled
exe  ctqmc        # Name of the executable
tsample  50       # How often to record measurements
nomD  150     # Number of Matsubara frequency points sampled
Ed [ -25.173284, -25.106338, -25.438896, -25.039819, -25.438835, -25.173295, -25.106388, -25.438915, -25.039860, -25.438873]     # Impurity levels updated by bash script
M 75000000.0        # Total number of Monte Carlo steps
Ncout  200000     # How often to print out info
PChangeOrder  0.9     # Ratio between trial steps: add-remove-a-kink / move-a-kink
CoulombF  'Ising'     # Ising Coulomb interaction
mu   25.173284  # QMC chemical potential by bash script 
warmup  100000       # Warmup number of QMC steps
GlobalFlip  200000        # How often to try a global flip
OCA_G  False      # No OCA diagrams being computed - for speed
sderiv  0.01      # Maximum derivative mismatch accepted for tail concatenation
aom  3        # Number of frequency points used to determin the value of sigma at nom
HB2  False        # Should we compute self-energy with the Bullas trick?
U    5.0
J    0.8
nf0  6.0
beta 50.0
</code></pre><p>At the bottom of the file we notice the physical parameters, the Hubbard parameters $U,J$, the inverse temperature $\beta$ and the occupancy of the correlated orbitals $n_{f0}$ (set in accordance with the values previously selected in ). In addition, we notice the two line copied from the <em style="color: green">Eimp.inp</em> file, one labelled by <em>Ed</em> (4th line of the file), and one labelled by <em>M</em> (last line of the file). <br /> All the other parameters control the stochastic character of the Monte-Carlo calculation. For more details about these, and some tips on how to tune them, in order not to be redundant we refer again to L.Sponza’s <a href="/tutorial/qsgw_dmft/dmft3">tutorial</a>.</p> <h5 id="treating-d-systems-the-script-atomdpy-and-the-file-transdat"><em>Treating d-systems: the script atom_d.py and the file Trans.dat</em></h5> <p>The <em style="color: blue">atom_d.py</em> is a python script written by K. Haule. It is specifically set for $d$-systems (not adopted otherwise) and its purpose is to initialize the atomic problem for the specific atom considered and to transform the Coulomb interaction $U$ via a rotation to the correct harmonics basis. <br /> The input file needed by is called <em style="color: green">Trans.dat</em>, it contains information about the local basis and in particular the transformation matrix from standard spherical Harmonics to a given user’s specified basis which is more convenient for the calculation. There are basically just two main cases of the file, the user can find an example at the following links, <a href="/assets/download/inputfiles/Trans.dat-spinpol">one</a> for non-magnetic and <a href="/assets/download/inputfiles/Trans.dat-nonmag">one</a> for spin-polarized calculations. <br /> The execution line for <em style="color: blue">atom_d.py</em> requires some specific flags indicating parameters such as angular momentum and the starting impurity levels (the correct instructions on how to run it can be found at this <a href="/tutorial/qsgw_dmft/dmft2">page</a> ). The main output file of the script is file <em style="color: green">actqmc.cix</em>. This file file has information regarding the atomic basis and the matrix elements of $U$ and is used as an input by the <em>CTQMC</em> solver and has to be copied in the <em style="color: green">it#_qmcrun</em> folder. Two log files are produced by the script, <em style="color: green">info_atom_d.dat</em> and <em style="color: green">new.cix</em>, both not required by <em>CTQMC</em>.</p> <h5 id="the-deltainp-and-eimpinp-input-files"><em>The Delta.inp and Eimp.inp Input Files</em></h5> <p>These files are soft linked and renamed from <em style="color: green">it#_lmf</em> folder (containing the results of the iteration preceding the <em>CTQMC</em> run). The <em style="color: green">Delta.inp</em> is directly taken as an input by <em>CTQMC</em>, whereas the <em style="color: green">Eimp.inp</em> is parsed and taken as input by 2 scripts composing the interface. In the first place the 3rd line, namely (see previous chapter for comparison):</p><pre><code>Eimp=[ 0.000000, 0.066946, -0.265612, 0.133464, -0.265551,-0.000011, 0.066895, -0.265631, 0.133423, -0.265589]
</code></pre><p>is copied in the execution line to run the script, object of next section. The fourth and fifth lines,</p><pre><code>Ed [ -25.173284, -25.106338, -25.438896, -25.039819, -25.438835,
-25.173295, -25.106388, -25.438915, -25.039860, -25.438873] # Ed
: Eimp-Edc for PARAMS
mu 25.173284 # mu = -Eimp[0] for PARAMS
</code></pre><p>are instead used in the file (introduced further on).</p> <h5 id="the-broadsigf90-script"><em>The broad_sig.f90 Script</em></h5> <p>This is the only script treating the output files. It takes the <em style="color: green">Sig.out</em> file, output of <em>CTQMC</em> containing the impurity self-energy, and it applies a Gaussian broadening to it in order to lessen the statistical noise. Every channel of the self-energy (i.e. its orbital component) is convoluted with a Gaussian distribution with a frequency-dependent width. <br /> This script allow the user to specify the Gaussian width, the total number of frequency points of the broadened self-energy, the starting and ending frequency, depending on the noise and shape of the starting input function. <br /> The fortran routine <strong style="color: blue">broad_sig.f90</strong> has obviously to be compiled so to obtain the <em style="color: blue">broad_sig.x</em> executable. For instructions on how to compile the program and run the executable inspect this <a href="/tutorial/qsgw_dmft/dmft2">page</a> of the tutorial. <br /> The resulting broadened self-energy is recorded in file <em style="color: green">Sig.out.brd</em> wheres files <em style="color: green">broad.log</em> and <em style="color: green">width.log</em> respectively list the parameters used in the broadening and the values of the Gaussian width as a function of the frequency.</p> <h4 id="outputs-of-ctqmc"><em>Outputs of CTQMC</em></h4><pre><code>#Outputs of CTQMC run
Probability.dat
g_qmc.dat
g_hb0.dat
s_hb1.dat
g_hb1.dat
Gtau.dat
histogram.dat
Sig.out
Gf.out
ctqmc.log
statusfiles/
</code></pre><p>We can differentiate these files into 2 categories. In the first category are files which are useful to judge the quality of the calculation, and among these enter all the <em style="color: green">*.dat</em> files and the log file <em style="color: green">ctqmc.log</em>. For a preliminary discussion on these files, which will have to be extended by someone more familiar with program, we refer again to this <a href="/tutorial/qsgw_dmft/dmft2">tutorial</a>. <br /> A special remark must be undertaken for the so called <em style="color: green">statusfiles</em>. For any <em>CTQMC</em> run, which is parallelized on a given number $N$ of cores, $N$ status files named <em style="color: green">status.#</em> will be produced with infos about the sampling. In order to improve the quality of the calculation, these files have to be copied to the folder containing the following step of <em>CTQMC</em> in such a way to be read by the program at the start. In the case the a single run of <em>CTQMC</em> is not enough to produce a sensible impurity self-energy, which might be too affected by statistical noise, the program can be re-run with the same instructions and inputs and the status files just produced will be also read to improve the accuracy of the sampling. <br /> To the second group belong the actual output files of the calculation. The file <em style="color: green">Gf.out</em> contains the impurity Green’s function and the file <em style="color: green">Sig.out</em> the impurity self-energy, both files affected by the statistical noise of the Monte-Carlo sampling. In particular the Monte-Carlo sampling accurately accounts for the low frequency region of the self-energy, whereas it is known to be extremely noisy for the high-frequency regime. In order for the self-energy to approach its Hartree-Fock value in the high-energy limit, the high-frequency tails are analytically corrected and concatenated with the Monte-Carlo sampling according to boundary conditions on value and slope. The <em>CTQMC</em> program make use of the Hubbard I approximation for the tails. <br /> To get rid of statistical noise the <em style="color: green">Sig.out</em> undergoes the <em style="color: blue">broad_sig.x</em> broadening to return the <em style="color: green">Sig.out.brd</em> file, which gets soft linked to the <em style="color: green">sig.inp</em> file entering the following iteration of in such a way to restart the cycle.</p> <h4 id="bonus-track-a-fully-inclusive-interface"><em>Bonus Track: A Fully Inclusive Interface</em></h4> <p>At this point the user should have all the means to run a full QSGW+DMFT loop from scratch using the QUESTAAL program, assisted by this manual and following L. Sponza’s tutorials step by step. <br /> If this is the case, an inclusive set of scripts will allow him/her to run a full calculation in one go by just setting in advance all the parameters required. These scripts automatize the several operations needed to connect the <strong style="color: blue">lmfdmft</strong> block to the <em>CTQMC</em> one in such a way to build a more user-friendly interface. They have been written mainly by L.Sponza and they are organized as follows. <br /> A central script <strong style="color: blue">Contlte.sh</strong> reads a file called <em style="color: green">LoopParams.sh</em> with all the overall parameters needed to set the DMFT calculation (provided that all of the input files discussed in this manual have already been set up in the respective input folders <em style="color: green">qmcinput</em>, <em style="color: green">lmfinput</em> ) and prepares the folders hosting the calculation of the two main programs. After that, it subsequently submits the corresponding scripts, which have to be also prepared in advance in the respective input folders, containing the execution lines for the two programs. <br /> A self-explanatory example of the main script <strong style="color: green">Contlte.sh</strong> can be found at this <a href="/assets/download/scripts/ContIte.sh">link</a>, together with an <a href="/assets/download/inputfiles/LoopParams.sh">example</a> of the <em style="color: green">LoopParam.sh</em> file. An example of the two scripts, <a href="/assets/download/scripts/lmfscript.sh">one</a> for the <strong style="color: blue">lmfdmft</strong> run (which in this version runs on a single processor) and <a href="/assets/download/scripts/qmcscript.sh">one</a> for the <em>CTQMC</em> run (which runs in parallel on a given number of cores) is also provided.</p> <h3 id="references"><em>References</em></h3> <hr /> <p>[1] K. Haule, C.H. Yee, and K. Kim. Dynamical mean field theory within the full-potential methods: Electronic structure of ceirin5, cecoin5, and cerhin5. Phys. Rev. B, 81:195107, 2010. <br /> [2] Paolo Pisanti. A novel QSGW+DMFT method for the study of strongly correlated materials. PhD thesis, King’s College London, 2016.</p> </article> </div><!-- /.medium-12.columns --> </div><!-- /.row --> <div id="up-to-top" class="row"> <div class="small-12 columns" style="text-align: right;"> <a class="iconfont" href="#top-of-page">&#xf108;</a> </div><!-- /.small-12.columns --> </div><!-- /.row --> <footer id="footer-content" class="bg-grau"> <div id="footer"> <div class="row"> <div class="medium-6 large-5 columns"> <h5 class="shadow-black">About This Site</h5> <p class="shadow-black"> Questaal is a suite of programs for LMTO and GW simulations. <a href="https://lordcephei.github.io/info/">More ›</a> </p> </div><!-- /.large-6.columns --> <div class="small-6 medium-3 large-3 large-offset-1 columns"> <h5 class="shadow-black">Services</h5> <ul class="no-bullet shadow-black"> <li > <a href="https://lordcephei.github.io" title=""></a> </li> <li class="services-contact" > <a href="https://lordcephei.github.io/contact/" title="Contact">Contact</a> </li> <li class="list" > <a href="https://lordcephei.github.io/developers/" title="Contact the developers">Developers</a> </li> </ul> </div><!-- /.large-4.columns --> <div class="small-6 medium-3 large-3 columns"> <h5 class="shadow-black">Related websites</h5> <ul class="no-bullet shadow-black"> <li > <a href="https://lordcephei.github.io" title=""></a> </li> <li class="network-entypo" > <a href="http://lmsuite.org" target="_blank" title="">Original LM Suite</a> </li> </ul> </div><!-- /.large-3.columns --> </div><!-- /.row --> </div><!-- /#footer --> </footer> <script src="https://lordcephei.github.io/assets/js/javascript.min.js"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-60112281-1', 'auto'); ga('set', 'anonymizeIp', true); ga('send', 'pageview'); </script> </body> </html>
